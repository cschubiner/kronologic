<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Digital Note Sheet - Kronologic Generator</title>
    <script src="https://unpkg.com/cytoscape@3.28.1/dist/cytoscape.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            padding: 20px;
            background: #f5f5f5;
            color: #333;
            -webkit-tap-highlight-color: transparent;
            touch-action: pan-y;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        h1 {
            margin-bottom: 20px;
            color: #1a1a1a;
            font-size: 24px;
        }

        .controls {
            margin-bottom: 20px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
        }

        .controls label {
            font-weight: 600;
            margin-right: 5px;
        }

        .controls input, .controls select {
            padding: 6px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        .controls button {
            padding: 10px 18px;
            background: #3b82f6;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            min-height: 44px;
            touch-action: manipulation;
        }

        .controls button:hover {
            background: #2563eb;
        }

        .controls button:active {
            background: #1d4ed8;
            transform: scale(0.98);
        }

        .controls button:disabled {
            background: #9ca3af;
            cursor: not-allowed;
        }

        .controls button.generate-graph {
            background: #10b981;
        }

        .controls button.generate-graph:hover {
            background: #059669;
        }

        .controls button.generate-graph:active {
            background: #047857;
        }

        /* Time-step maps grid */
        .maps-grid {
            display: grid;
            gap: 16px;
            margin-bottom: 30px;
        }

        .maps-grid.cols-4 {
            grid-template-columns: repeat(4, 1fr);
        }

        .maps-grid.cols-3 {
            grid-template-columns: repeat(3, 1fr);
        }

        .maps-grid.cols-2 {
            grid-template-columns: repeat(2, 1fr);
        }

        .map-card {
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            overflow: hidden;
            background: white;
        }

        .map-header {
            background: #3b82f6;
            color: white;
            padding: 10px;
            font-weight: 600;
            text-align: center;
            font-size: 14px;
        }

        .map-container {
            height: 300px;
            position: relative;
            background: #fafafa;
        }

        .cytoscape-container {
            width: 100%;
            height: 100%;
        }

        /* Character chips */
        .character-chips {
            position: absolute;
            pointer-events: none;
        }

        .character-chip {
            display: inline-block;
            padding: 2px 6px;
            margin: 2px;
            border-radius: 3px;
            font-size: 10px;
            font-weight: 600;
            color: white;
            pointer-events: auto;
            cursor: pointer;
            user-select: none;
        }

        .character-chip.strikethrough {
            text-decoration: line-through;
            text-decoration-color: red;
            text-decoration-thickness: 2px;
            opacity: 0.6;
        }

        /* Character selector popup */
        .character-selector {
            position: fixed;
            background: white;
            border: 2px solid #3b82f6;
            border-radius: 8px;
            padding: 16px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            z-index: 1000;
            min-width: 250px;
            max-width: 90vw;
        }

        .character-selector.hidden {
            display: none;
        }

        .character-selector .header {
            font-weight: 600;
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 1px solid #e5e7eb;
            font-size: 13px;
        }

        .room-count {
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
        }

        .room-count label {
            font-weight: 600;
            font-size: 13px;
            color: #1f2937;
        }

        .room-count input {
            width: 80px;
            padding: 8px;
            text-align: center;
            border: 2px solid #d1d5db;
            border-radius: 6px;
            font-size: 14px;
            min-height: 40px;
            touch-action: manipulation;
        }

        .character-grid {
            display: grid;
            gap: 6px;
        }

        .character-option {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 14px;
            border: 2px solid;
            border-radius: 6px;
            background: white;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.1s;
            min-height: 48px;
            touch-action: manipulation;
        }

        .character-option:hover {
            background: #f3f4f6;
        }

        .character-option:active {
            background: #e5e7eb;
            transform: scale(0.97);
        }

        .character-option .initial {
            font-weight: 700;
            width: 20px;
            text-align: center;
        }

        .character-selector .existing-chips {
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid #e5e7eb;
        }

        .existing-chips .chip-item {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 4px;
            margin: 2px 0;
            font-size: 12px;
        }

        .chip-item button {
            padding: 8px 12px;
            font-size: 12px;
            background: #6b7280;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            min-height: 36px;
            touch-action: manipulation;
            transition: all 0.1s;
        }

        .chip-item button:hover {
            background: #4b5563;
        }

        .chip-item button:active {
            background: #374151;
            transform: scale(0.95);
        }

        .chip-item button.strike {
            background: #ef4444;
        }

        .chip-item button.strike:hover {
            background: #dc2626;
        }

        .chip-item button.strike:active {
            background: #b91c1c;
        }

        /* Character tracking table */
        .tracking-section {
            margin: 30px 0;
        }

        .tracking-section h2 {
            font-size: 18px;
            margin-bottom: 12px;
            color: #1a1a1a;
        }

        .tracking-table-wrapper {
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
            margin: 0 -20px;
            padding: 0 20px;
        }

        .tracking-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 13px;
            min-width: 600px;
        }

        .tracking-table th,
        .tracking-table td {
            border: 1px solid #e5e7eb;
            padding: 4px 6px;
            text-align: center;
        }

        .tracking-table th {
            background: #f3f4f6;
            font-weight: 600;
        }

        .tracking-table td.character-name {
            text-align: left;
            font-weight: 500;
            background: #fafafa;
            padding: 4px 8px;
        }

        .tracking-table input {
            width: 45px;
            padding: 4px;
            text-align: center;
            border: 1px solid #d1d5db;
            border-radius: 3px;
            font-size: 14px;
            min-height: 32px;
            touch-action: manipulation;
        }

        /* Notes area */
        .notes-section {
            margin: 30px 0;
        }

        .notes-section h2 {
            font-size: 18px;
            margin-bottom: 12px;
            color: #1a1a1a;
        }

        .notes-toolbar {
            display: flex;
            gap: 4px;
            margin-bottom: 8px;
            padding: 8px;
            background: #f3f4f6;
            border: 1px solid #e5e7eb;
            border-radius: 4px 4px 0 0;
        }

        .notes-toolbar button {
            padding: 10px 14px;
            background: white;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            min-height: 42px;
            touch-action: manipulation;
            transition: all 0.1s;
        }

        .notes-toolbar button:hover {
            background: #e5e7eb;
        }

        .notes-toolbar button:active {
            background: #d1d5db;
            transform: scale(0.96);
        }

        .notes-editor {
            width: 100%;
            min-height: 200px;
            padding: 12px;
            border: 1px solid #e5e7eb;
            border-top: none;
            border-radius: 0 0 4px 4px;
            font-family: inherit;
            font-size: 14px;
            line-height: 1.6;
            resize: vertical;
        }

        .notes-editor:focus {
            outline: none;
            border-color: #3b82f6;
        }

        /* Graph input section */
        .graph-input-section {
            margin: 20px 0;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #e5e7eb;
        }

        .graph-input-section h3 {
            font-size: 16px;
            margin-bottom: 10px;
            color: #1a1a1a;
        }

        .graph-input-section p {
            font-size: 13px;
            color: #6b7280;
            margin-bottom: 10px;
        }

        .graph-input-area {
            width: 100%;
            min-height: 120px;
            padding: 10px;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.5;
            resize: vertical;
            background: white;
        }

        .graph-input-area:focus {
            outline: none;
            border-color: #3b82f6;
        }

        .graph-error {
            color: #ef4444;
            font-size: 13px;
            margin-top: 8px;
            display: none;
        }

        .graph-error.show {
            display: block;
        }

        /* Save status indicator */
        .save-status {
            position: fixed;
            bottom: 90px;
            right: 20px;
            background: #10b981;
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            z-index: 850;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .save-status.show {
            opacity: 1;
        }

        .save-status.error {
            background: #ef4444;
        }

        /* Session management */
        .session-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            padding: 10px;
            background: #fef3c7;
            border: 1px solid #fbbf24;
            border-radius: 6px;
            align-items: center;
        }

        .session-controls .info {
            flex: 1;
            font-size: 13px;
            color: #92400e;
        }

        .session-controls button {
            padding: 6px 12px;
            font-size: 13px;
            background: #f59e0b;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            min-height: 36px;
        }

        .session-controls button:hover {
            background: #d97706;
        }

        @media (max-width: 768px) {
            .save-status {
                bottom: 140px;
                right: 10px;
                font-size: 11px;
                padding: 6px 12px;
            }

            .session-controls {
                flex-direction: column;
                align-items: stretch;
            }

            .session-controls .info {
                margin-bottom: 8px;
            }
        }

        /* Floating action buttons for mobile */
        .floating-actions {
            position: fixed;
            bottom: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 900;
        }

        .floating-btn {
            width: 56px;
            height: 56px;
            border-radius: 50%;
            background: #3b82f6;
            color: white;
            border: none;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            cursor: pointer;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            touch-action: manipulation;
        }

        .floating-btn:active {
            transform: scale(0.9);
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        .floating-btn:disabled {
            background: #9ca3af;
            opacity: 0.6;
        }

        .floating-btn.redo-btn {
            background: #10b981;
        }

        @media (min-width: 769px) {
            .floating-actions {
                display: none;
            }
        }

        @media (max-width: 1024px) {
            .maps-grid.cols-4 {
                grid-template-columns: repeat(3, 1fr);
            }
        }

        @media (max-width: 768px) {
            body {
                padding: 10px;
            }

            .container {
                padding: 15px;
            }

            h1 {
                font-size: 20px;
                margin-bottom: 15px;
            }

            .controls {
                gap: 8px;
            }

            .controls input {
                font-size: 16px;
            }

            .maps-grid.cols-4,
            .maps-grid.cols-3 {
                grid-template-columns: repeat(2, 1fr);
                gap: 12px;
            }

            .map-container {
                height: 250px;
            }

            .character-selector {
                position: fixed;
                left: 50% !important;
                top: 50% !important;
                transform: translate(-50%, -50%);
                max-height: 80vh;
                overflow-y: auto;
            }

            .tracking-table-wrapper {
                margin: 0 -15px;
                padding: 0 15px;
            }

            .tracking-table {
                font-size: 12px;
            }

            .tracking-table th,
            .tracking-table td {
                padding: 6px 4px;
                white-space: nowrap;
            }

            .tracking-table input {
                width: 40px;
                font-size: 14px;
                padding: 6px 4px;
            }
        }

        @media (max-width: 480px) {
            .maps-grid.cols-4,
            .maps-grid.cols-3,
            .maps-grid.cols-2 {
                grid-template-columns: 1fr;
            }

            .map-container {
                height: 280px;
            }

            .controls label {
                width: 100%;
            }

            .controls input[type="text"] {
                width: 100%;
            }

            .controls button {
                flex: 1;
                min-width: 120px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Digital Note Sheet - Kronologic Generator</h1>

        <!-- Session management -->
        <div class="session-controls" id="sessionControls" style="display: none;">
            <span class="info">Session restored from previous visit</span>
            <button onclick="clearSession()">Clear Session</button>
        </div>

        <div class="graph-input-section">
            <h3>Map Graph Definition</h3>
            <p>Enter your map structure using Mermaid graph syntax:</p>
            <textarea class="graph-input-area" id="graphInput" placeholder="graph TD
  Foyer --- Stairs
  Foyer --- Gallery
  Gallery --- Stairs
  Gallery --- Masks
  Masks --- DanceRoom
  Masks --- MusicRoom
  MusicRoom --- DanceRoom">graph TD
  Foyer --- Stairs
  Foyer --- Gallery
  Gallery --- Stairs
  Gallery --- Masks
  Masks --- DanceRoom
  Masks --- MusicRoom
  MusicRoom --- DanceRoom</textarea>
            <div class="graph-error" id="graphError"></div>
        </div>

        <div class="controls">
            <label>Timesteps:</label>
            <input type="number" id="timestepCount" min="3" max="8" value="6">

            <label>Characters:</label>
            <input type="text" id="characterNames" value="A,B,C,D,S,J" placeholder="Comma-separated names">

            <button onclick="initializeSheet()">Initialize Sheet</button>
            <button class="generate-graph" onclick="regenerateGraphLayout()" id="generateGraphBtn" disabled>Generate Graph</button>
            <button onclick="undo()" id="undoBtn" disabled>Undo</button>
            <button onclick="redo()" id="redoBtn" disabled>Redo</button>
        </div>

        <div id="mapsGrid" class="maps-grid cols-4">
            <!-- Time-step maps will be generated here -->
        </div>

        <div class="tracking-section">
            <h2>Character Visits per Location</h2>
            <div class="tracking-table-wrapper">
                <table class="tracking-table" id="trackingTable">
                    <!-- Table will be generated here -->
                </table>
            </div>
        </div>

        <div class="notes-section">
            <h2>Deduction Notes</h2>
            <div class="notes-toolbar">
                <button onclick="formatText('bold')"><b>B</b></button>
                <button onclick="formatText('italic')"><i>I</i></button>
                <button onclick="formatText('underline')"><u>U</u></button>
                <button onclick="insertBullet()">• Bullet</button>
            </div>
            <textarea class="notes-editor" id="notesEditor" placeholder="Enter your deduction notes here..."></textarea>
        </div>

        <div class="tracking-section">
            <h2>Scenario Reference Guide</h2>
            <div style="padding: 15px; background: #f8f9fa; border-radius: 8px; border: 1px solid #e5e7eb; font-size: 13px; line-height: 1.6;">
                <details style="margin-bottom: 12px;">
                    <summary style="cursor: pointer; font-weight: 600; color: #1a1a1a; padding: 8px 0;">S1: Poison (Assassin)</summary>
                    <div style="padding: 8px 0 0 16px; color: #4b5563;">
                        <p><strong>Mystery:</strong> One character poisoned someone at a specific time and location.</p>
                        <p><strong>Rules:</strong></p>
                        <ul style="margin: 8px 0; padding-left: 20px;">
                            <li>The assassin is always the <strong>first character</strong> in your character list</li>
                            <li>Exactly one victim (not the assassin) was poisoned</li>
                            <li>At exactly one (time, room) pair (the "poison moment"):
                                <ul style="margin: 4px 0; padding-left: 20px;">
                                    <li>The assassin and victim are both present</li>
                                    <li>NO other characters are present (exactly 2 people total)</li>
                                </ul>
                            </li>
                            <li>At ALL other (time, room) pairs where the assassin is present:
                                <ul style="margin: 4px 0; padding-left: 20px;">
                                    <li>Either the assassin is completely alone (1 person), OR</li>
                                    <li>At least 2 other people are present with the assassin (3+ people total)</li>
                                    <li>The assassin is NEVER alone with exactly one other person except at the poison moment</li>
                                </ul>
                            </li>
                        </ul>
                        <p><strong>Goal:</strong> Identify the victim, poison time, and poison room.</p>
                    </div>
                </details>

                <details style="margin-bottom: 12px;">
                    <summary style="cursor: pointer; font-weight: 600; color: #1a1a1a; padding: 8px 0;">S2: Phantom</summary>
                    <div style="padding: 8px 0 0 16px; color: #4b5563;">
                        <p><strong>Mystery:</strong> One character was mysteriously alone at every single timestep.</p>
                        <p><strong>Rules:</strong></p>
                        <ul style="margin: 8px 0; padding-left: 20px;">
                            <li>Exactly one character is the phantom</li>
                            <li>At EVERY timestep (t=1, t=2, ..., t=T):
                                <ul style="margin: 4px 0; padding-left: 20px;">
                                    <li>The phantom is in some room</li>
                                    <li>NO other character is in the same room as the phantom</li>
                                    <li>The phantom is completely isolated at that timestep</li>
                                </ul>
                            </li>
                            <li>All non-phantom characters must share a room with at least one other character at some point during the timeline</li>
                        </ul>
                        <p><strong>Goal:</strong> Identify which character is the phantom.</p>
                    </div>
                </details>

                <details style="margin-bottom: 12px;">
                    <summary style="cursor: pointer; font-weight: 600; color: #1a1a1a; padding: 8px 0;">S4: Bomb Duo</summary>
                    <div style="padding: 8px 0 0 16px; color: #4b5563;">
                        <p><strong>Mystery:</strong> Two accomplices are planning something suspicious.</p>
                        <p><strong>Rules:</strong></p>
                        <ul style="margin: 8px 0; padding-left: 20px;">
                            <li>Exactly two characters are the bombers (A1 and A2)</li>
                            <li>The bombers are distinct (A1 ≠ A2)</li>
                            <li>They must be alone together (exactly those two, no one else) in at least one room/time</li>
                            <li><strong>Critical constraint:</strong> For ANY (time, room) pair, if exactly 2 characters are present in that room at that time, those 2 characters MUST be the bombers</li>
                            <li>Equivalently: The bombers are the ONLY pair who can ever be alone together</li>
                            <li>Other character groupings are allowed:
                                <ul style="margin: 4px 0; padding-left: 20px;">
                                    <li>1 person (anyone can be alone, including bombers)</li>
                                    <li>3+ people (any combination, including with or without bombers)</li>
                                </ul>
                            </li>
                            <li>But exactly 2 people in a room is ONLY allowed if those 2 are the bombers</li>
                        </ul>
                        <p><strong>Goal:</strong> Identify the two bombers.</p>
                    </div>
                </details>

                <details style="margin-bottom: 12px;">
                    <summary style="cursor: pointer; font-weight: 600; color: #1a1a1a; padding: 8px 0;">S5: Lovers</summary>
                    <div style="padding: 8px 0 0 16px; color: #4b5563;">
                        <p><strong>Mystery:</strong> Two characters are secret lovers who never meet.</p>
                        <p><strong>Rules:</strong></p>
                        <ul style="margin: 8px 0; padding-left: 20px;">
                            <li>Exactly two characters are the lovers (L1 and L2)</li>
                            <li>The lovers are distinct (L1 ≠ L2)</li>
                            <li>The lovers NEVER share a room at any timestep:
                                <ul style="margin: 4px 0; padding-left: 20px;">
                                    <li>For ALL (time, room) pairs: L1 and L2 are never both present</li>
                                </ul>
                            </li>
                            <li><strong>Every pair of non-lovers must meet at least once:</strong>
                                <ul style="margin: 4px 0; padding-left: 20px;">
                                    <li>For any two characters who are NOT both lovers, they must share a room at some (time, room) pair</li>
                                    <li>This ensures all non-lovers encounter each other at least once</li>
                                    <li>The lovers themselves never meet each other</li>
                                </ul>
                            </li>
                        </ul>
                        <p><strong>Goal:</strong> Identify the two lovers.</p>
                    </div>
                </details>

                <details style="margin-bottom: 12px;">
                    <summary style="cursor: pointer; font-weight: 600; color: #1a1a1a; padding: 8px 0;">S6: Phantom + Lovers</summary>
                    <div style="padding: 8px 0 0 16px; color: #4b5563;">
                        <p><strong>Mystery:</strong> One character is a phantom (alone at every timestep) AND there are two lovers who never meet.</p>
                        <p><strong>Rules:</strong></p>
                        <ul style="margin: 8px 0; padding-left: 20px;">
                            <li>Combines S2 (Phantom) and S5 (Lovers) constraints</li>
                            <li>Exactly one character is the phantom:
                                <ul style="margin: 4px 0; padding-left: 20px;">
                                    <li>At EVERY timestep, the phantom is alone in their room</li>
                                    <li>NO other character shares a room with the phantom at any time</li>
                                    <li>The phantom is in their own category - neither a lover nor a non-lover</li>
                                </ul>
                            </li>
                            <li>Exactly two characters are the lovers (L1 and L2):
                                <ul style="margin: 4px 0; padding-left: 20px;">
                                    <li>The lovers NEVER share a room at any timestep</li>
                                    <li>The lovers are distinct from the phantom</li>
                                    <li><strong>Neither lover can be the phantom</strong> (phantom is always alone, so can't have a relationship)</li>
                                </ul>
                            </li>
                            <li><strong>Every pair of non-phantom, non-lovers must meet at least once:</strong>
                                <ul style="margin: 4px 0; padding-left: 20px;">
                                    <li>For any two characters who are NOT lovers AND NOT the phantom, they must share a room at some point</li>
                                    <li>This ensures all "regular" characters encounter each other</li>
                                    <li>The phantom is excluded from this requirement (they never meet anyone)</li>
                                </ul>
                            </li>
                        </ul>
                        <p><strong>Goal:</strong> Identify the phantom and the two lovers.</p>
                    </div>
                </details>

                <details style="margin-bottom: 12px;">
                    <summary style="cursor: pointer; font-weight: 600; color: #1a1a1a; padding: 8px 0;">S7: Aggrosassin</summary>
                    <div style="padding: 8px 0 0 16px; color: #4b5563;">
                        <p><strong>Mystery:</strong> One character is a serial poisoner who kills everyone they meet one-on-one.</p>
                        <p><strong>Rules:</strong></p>
                        <ol style="margin: 8px 0; padding-left: 20px;">
                            <li><strong>Exactly one aggrosassin</strong> exists (can be any character, not necessarily the first)</li>
                            <li><strong>Minimum kill frequency:</strong> The aggrosassin must be in a 1-on-1 meeting (exactly 2 people in a room) for at least <strong>⌈T/2⌉ timesteps</strong>
                                <ul style="margin: 4px 0; padding-left: 20px;">
                                    <li>Example: With T=6, the aggrosassin must have 1-on-1 meetings in at least 3 different timesteps</li>
                                    <li>This ensures the aggrosassin is actively hunting throughout the timeline</li>
                                </ul>
                            </li>
                            <li><strong>Double the face time:</strong> The aggrosassin has at least twice as many 1-on-1 meetings as any other single character
                                <ul style="margin: 4px 0; padding-left: 20px;">
                                    <li>They still appear in at least ⌈T/2⌉ one-on-one encounters overall</li>
                                    <li>Other characters may share 1-on-1 rooms, but none of them rival the aggrosassin's cadence</li>
                                </ul>
                            </li>
                            <li><strong>Victims:</strong> The aggrosassin kills everyone they meet 1-on-1
                                <ul style="margin: 4px 0; padding-left: 20px;">
                                    <li>Victims = all characters who were alone with the aggrosassin at any timestep</li>
                                    <li>A character can be alone with the aggrosassin multiple times (still counts as one victim)</li>
                                </ul>
                            </li>
                            <li><strong>Flexibility otherwise:</strong> The aggrosassin can travel alone, meet victims repeatedly, or hide inside larger groups between kills
                                <ul style="margin: 4px 0; padding-left: 20px;">
                                    <li>Repeated meetings with the same victim are allowed, and non-aggrosassin pairs can appear as red herrings</li>
                                </ul>
                            </li>
                        </ol>
                        <p><strong>Goal:</strong> Identify the aggrosassin and determine how many victims they claimed.</p>
                    </div>
                </details>

                <details style="margin-bottom: 12px;">
                    <summary style="cursor: pointer; font-weight: 600; color: #1a1a1a; padding: 8px 0;">S8: The Freeze</summary>
                    <div style="padding: 8px 0 0 16px; color: #4b5563;">
                        <p><strong>Mystery:</strong> Mr. Freeze is on the loose. Anyone they catch alone is frozen in place for the rest of the timeline.</p>
                        <p><strong>Rules:</strong></p>
                        <ul style="margin: 8px 0; padding-left: 20px;">
                            <li><strong>Exactly one character is the Freeze</strong> (randomly chosen from all characters)</li>
                            <li>Whenever the Freeze shares a room with exactly <strong>one</strong> other person, that person is frozen</li>
                            <li>Frozen characters remain in that room for all remaining timesteps (even if <code>mustMove=true</code>)</li>
                            <li><strong>Randomized kill constraints:</strong> The scenario randomly requires:
                                <ul style="margin: 4px 0; padding-left: 20px;">
                                    <li>Between 1-3 kills to occur</li>
                                    <li>Specific timesteps where kills must happen (excluding the final timestep)</li>
                                    <li>This creates variety - some scenarios have early kills, others have kills spread throughout</li>
                                </ul>
                            </li>
                            <li>Frozen victims can be visited later, but they never move again</li>
                        </ul>
                        <p><strong>Goal:</strong> Identify Mr. Freeze and list every frozen victim (with their freeze moments).</p>
                        <p><strong>Difficulty Factors:</strong></p>
                        <ul style="margin: 8px 0; padding-left: 20px;">
                            <li>More frozen victims make the pattern more obvious (easier to identify)</li>
                            <li>1-on-1 meetings between non-Freeze characters act as red herrings and increase difficulty</li>
                            <li>The randomized kill timing creates unpredictable patterns across different scenarios</li>
                        </ul>
                    </div>
                </details>

                <p style="margin-top: 12px; font-size: 12px; color: #6b7280; font-style: italic;">
                    Note: Only ONE scenario is active per puzzle. Use this guide to understand the rules and constraints for the scenario you're solving.
                </p>
            </div>
        </div>

        <div style="margin: 20px 0; padding: 15px; background: #fef3c7; border: 1px solid #fbbf24; border-radius: 6px;">
            <button onclick="strikeAllEverywhere()" style="width: 100%; padding: 12px; background: #ef4444; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; font-weight: 600; min-height: 48px;">
                Strike All Characters for All Rooms for All Times
            </button>
            <p style="margin: 8px 0 0 0; font-size: 12px; color: #92400e;">
                This will add all characters to every room at every timestep with strikethrough enabled. Useful for starting elimination deductions.
            </p>
        </div>
    </div>

    <!-- Character selector popup -->
    <div id="characterSelector" class="character-selector hidden">
        <div class="header" id="selectorHeader">Add Character</div>
        <div class="room-count" id="roomCount"></div>
        <div class="character-grid" id="characterGrid"></div>
        <div class="existing-chips" id="existingChips"></div>
    </div>

    <!-- Floating action buttons for mobile -->
    <div class="floating-actions">
        <button class="floating-btn" id="floatingUndo" onclick="undo()" title="Undo">↶</button>
        <button class="floating-btn redo-btn" id="floatingRedo" onclick="redo()" title="Redo">↷</button>
    </div>

    <!-- Save status indicator -->
    <div class="save-status" id="saveStatus">Saved</div>

    <script>
        // State management
        let state = {
            timesteps: 6,
            characters: [
                { name: 'A', initial: 'A', color: '#3b82f6' },
                { name: 'B', initial: 'B', color: '#10b981' },
                { name: 'C', initial: 'C', color: '#ef4444' },
                { name: 'D', initial: 'D', color: '#f59e0b' },
                { name: 'S', initial: 'S', color: '#8b5cf6' },
                { name: 'J', initial: 'J', color: '#ec4899' }
            ],
            rooms: ['Foyer', 'Stairs', 'Gallery', 'Masks', 'DanceRoom', 'MusicRoom'],
            placements: {}, // { timestep: { room: [{ char, initial, color, strikethrough }] } }
            cytoscapeInstances: [],
            history: [],
            historyIndex: -1,
            currentSelector: null,
            currentLayoutIndex: 0,
            counts: {}
        };

        const characterColors = [
            '#3b82f6', '#10b981', '#ef4444', '#f59e0b',
            '#8b5cf6', '#ec4899', '#06b6d4', '#84cc16'
        ];

        // Graph elements will be generated from Mermaid syntax
        let graphElements = [];

        // LocalStorage key
        const STORAGE_KEY = 'kronologic_note_sheet_session';

        // Save status timeout
        let saveStatusTimeout = null;

        // LocalStorage functions
        function saveToLocalStorage() {
            try {
                const sessionData = {
                    version: '1.0',
                    timestamp: new Date().toISOString(),
                    config: {
                        timesteps: state.timesteps,
                        characters: state.characters,
                        rooms: state.rooms,
                        graphDefinition: document.getElementById('graphInput').value,
                        layoutIndex: state.currentLayoutIndex
                    },
                    placements: state.placements,
                    counts: state.counts,
                    notes: document.getElementById('notesEditor').value,
                    tracking: getTrackingTableData(),
                    history: state.history,
                    historyIndex: state.historyIndex
                };

                localStorage.setItem(STORAGE_KEY, JSON.stringify(sessionData));
                showSaveStatus('Saved', false);
                return true;
            } catch (error) {
                console.error('Failed to save to localStorage:', error);
                showSaveStatus('Save failed', true);
                return false;
            }
        }

        function loadFromLocalStorage() {
            try {
                const saved = localStorage.getItem(STORAGE_KEY);
                if (!saved) return false;

                const sessionData = JSON.parse(saved);

                // Validate version
                if (sessionData.version !== '1.0') {
                    console.warn('Incompatible session version');
                    return false;
                }

                // Restore config
                state.timesteps = sessionData.config.timesteps;
                state.characters = sessionData.config.characters;
                state.rooms = sessionData.config.rooms;
                state.currentLayoutIndex = sessionData.config.layoutIndex || 0;

                document.getElementById('timestepCount').value = state.timesteps;
                document.getElementById('characterNames').value = state.characters.map(c => c.name).join(',');
                document.getElementById('graphInput').value = sessionData.config.graphDefinition;

                // Parse graph
                const parsed = parseMermaidGraph(sessionData.config.graphDefinition);
                if (parsed) {
                    graphElements = parsed.elements;
                    state.rooms = parsed.roomNames;
                }

                // Restore placements
                state.placements = sessionData.placements;
                // Restore counts
                state.counts = sessionData.counts || {};

                // Restore notes
                document.getElementById('notesEditor').value = sessionData.notes || '';

                // Restore history
                state.history = sessionData.history || [];
                state.historyIndex = sessionData.historyIndex || -1;

                // Render everything
                renderMaps();
                renderTrackingTable();

                // Restore tracking table data
                if (sessionData.tracking) {
                    restoreTrackingTableData(sessionData.tracking);
                }

                updateUndoRedoButtons();

                // Show session controls
                document.getElementById('sessionControls').style.display = 'flex';
                document.getElementById('generateGraphBtn').disabled = false;

                return true;
            } catch (error) {
                console.error('Failed to load from localStorage:', error);
                return false;
            }
        }

        function getTrackingTableData() {
            const data = {};
            const inputs = document.querySelectorAll('.tracking-table input');
            inputs.forEach(input => {
                const char = input.dataset.char;
                const room = input.dataset.room;
                if (char && room && input.value) {
                    if (!data[char]) data[char] = {};
                    data[char][room] = input.value;
                }
            });
            return data;
        }

        function restoreTrackingTableData(data) {
            const inputs = document.querySelectorAll('.tracking-table input');
            inputs.forEach(input => {
                const char = input.dataset.char;
                const room = input.dataset.room;
                if (char && room && data[char] && data[char][room]) {
                    input.value = data[char][room];
                }
            });
        }

        function showSaveStatus(message, isError) {
            const indicator = document.getElementById('saveStatus');
            indicator.textContent = message;
            indicator.classList.toggle('error', isError);
            indicator.classList.add('show');

            // Clear previous timeout
            if (saveStatusTimeout) clearTimeout(saveStatusTimeout);

            // Hide after 2 seconds
            saveStatusTimeout = setTimeout(() => {
                indicator.classList.remove('show');
            }, 2000);
        }

        function clearSession() {
            if (confirm('Are you sure you want to clear all data and start fresh? This cannot be undone.')) {
                localStorage.removeItem(STORAGE_KEY);
                location.reload();
            }
        }

        // Available layout algorithms
        const layoutAlgorithms = [
            {
                name: 'cose',
                options: {
                    name: 'cose',
                    fit: true,
                    padding: 20,
                    nodeRepulsion: 8000,
                    idealEdgeLength: 80,
                    animate: false
                }
            },
            {
                name: 'circle',
                options: {
                    name: 'circle',
                    fit: true,
                    padding: 20,
                    animate: false
                }
            },
            {
                name: 'grid',
                options: {
                    name: 'grid',
                    fit: true,
                    padding: 20,
                    animate: false
                }
            },
            {
                name: 'breadthfirst',
                options: {
                    name: 'breadthfirst',
                    fit: true,
                    padding: 20,
                    directed: false,
                    spacingFactor: 1.5,
                    animate: false
                }
            },
            {
                name: 'concentric',
                options: {
                    name: 'concentric',
                    fit: true,
                    padding: 20,
                    minNodeSpacing: 40,
                    animate: false
                }
            },
            {
                name: 'cose-random',
                options: {
                    name: 'cose',
                    fit: true,
                    padding: 20,
                    nodeRepulsion: 10000,
                    idealEdgeLength: 60,
                    randomize: true,
                    animate: false
                }
            }
        ];

        // Parse Mermaid graph syntax
        function parseMermaidGraph(mermaidText) {
            const errorDiv = document.getElementById('graphError');
            errorDiv.classList.remove('show');

            try {
                const lines = mermaidText.trim().split('\n');
                const nodes = new Set();
                const edges = [];

                for (let line of lines) {
                    line = line.trim();

                    // Skip graph declaration line
                    if (line.startsWith('graph') || line === '') continue;

                    // Parse edge relationships: "NodeA --- NodeB" or "NodeA --- NodeB --- NodeC"
                    const parts = line.split('---').map(s => s.trim());

                    if (parts.length < 2) continue;

                    // Add all nodes and create edges between consecutive pairs
                    for (let i = 0; i < parts.length; i++) {
                        const node = parts[i];
                        if (node) nodes.add(node);

                        if (i < parts.length - 1) {
                            const nextNode = parts[i + 1];
                            if (nextNode) {
                                edges.push({ source: node, target: nextNode });
                            }
                        }
                    }
                }

                if (nodes.size === 0) {
                    throw new Error('No nodes found in graph definition');
                }

                // Convert to Cytoscape format
                const elements = [];

                // Add nodes
                nodes.forEach(nodeName => {
                    elements.push({
                        data: {
                            id: nodeName.toLowerCase().replace(/\s+/g, ''),
                            name: nodeName
                        }
                    });
                });

                // Add edges
                edges.forEach(edge => {
                    elements.push({
                        data: {
                            source: edge.source.toLowerCase().replace(/\s+/g, ''),
                            target: edge.target.toLowerCase().replace(/\s+/g, '')
                        }
                    });
                });

                return { elements, roomNames: Array.from(nodes) };
            } catch (error) {
                errorDiv.textContent = `Error parsing graph: ${error.message}`;
                errorDiv.classList.add('show');
                return null;
            }
        }

        function initializeSheet() {
            const timestepCount = parseInt(document.getElementById('timestepCount').value);
            const characterInput = document.getElementById('characterNames').value;
            const graphInput = document.getElementById('graphInput').value;

            // Parse the graph
            const parsed = parseMermaidGraph(graphInput);
            if (!parsed) {
                return; // Error message already shown
            }

            graphElements = parsed.elements;
            state.rooms = parsed.roomNames;

            state.timesteps = timestepCount;
            state.characters = characterInput.split(',').map((name, idx) => {
                const trimmed = name.trim();
                return {
                    name: trimmed,
                    initial: trimmed[0].toUpperCase(),
                    color: characterColors[idx % characterColors.length]
                };
            });

            // Reset placements
            state.placements = {};
            for (let t = 1; t <= timestepCount; t++) {
                state.placements[t] = {};
                state.rooms.forEach(room => {
                    state.placements[t][room] = [];
                });
            }

            // Reset counts
            state.counts = {};
            for (let t = 1; t <= timestepCount; t++) {
                state.counts[t] = {};
                state.rooms.forEach(room => {
                    state.counts[t][room] = null;
                });
            }

            // Clear history
            state.history = [];
            state.historyIndex = -1;
            updateUndoRedoButtons();

            // Reset layout index
            state.currentLayoutIndex = 0;

            // Render
            renderMaps();
            renderTrackingTable();
            saveState();

            // Enable generate graph button
            document.getElementById('generateGraphBtn').disabled = false;
        }

        function renderMaps() {
            const grid = document.getElementById('mapsGrid');
            grid.innerHTML = '';

            // Determine grid columns
            let cols = 4;
            if (state.timesteps >= 5 && state.timesteps <= 6) cols = 3;
            else if (state.timesteps >= 7) cols = 4;

            grid.className = `maps-grid cols-${cols}`;

            // Clear previous Cytoscape instances
            state.cytoscapeInstances.forEach(cy => cy.destroy());
            state.cytoscapeInstances = [];

            // Create map cards
            for (let t = 1; t <= state.timesteps; t++) {
                const card = document.createElement('div');
                card.className = 'map-card';
                card.innerHTML = `
                    <div class="map-header">TIME ${t}</div>
                    <div class="map-container">
                        <div id="cy-${t}" class="cytoscape-container"></div>
                    </div>
                `;
                grid.appendChild(card);

                // Initialize Cytoscape
                setTimeout(() => {
                    const currentLayout = layoutAlgorithms[state.currentLayoutIndex];
                    const cy = cytoscape({
                        container: document.getElementById(`cy-${t}`),
                        elements: graphElements,
                        layout: currentLayout.options,
                        style: [
                            {
                                selector: 'node',
                                style: {
                                    'label': 'data(name)',
                                    'font-size': '11px',
                                    'text-valign': 'center',
                                    'text-halign': 'center',
                                    'background-color': '#ffffff',
                                    'border-width': 3,
                                    'border-color': '#9ca3af',
                                    'width': 80,
                                    'height': 80,
                                    'text-wrap': 'wrap',
                                    'text-max-width': 70,
                                    'line-height': 1.4,
                                    'font-weight': 500
                                }
                            },
                            {
                                selector: 'edge',
                                style: {
                                    'width': 2,
                                    'line-color': '#d1d5db',
                                    'curve-style': 'bezier'
                                }
                            }
                        ],
                        autoungrabify: true,
                        userZoomingEnabled: false,
                        userPanningEnabled: false,
                        boxSelectionEnabled: false
                    });

                    // Add click handler
                    cy.on('tap', 'node', function(evt) {
                        const node = evt.target;
                        const roomName = node.data('name');
                        showCharacterSelector(t, roomName, evt.originalEvent);
                    });

                    // Update node colors based on placements
                    updateNodeColors(cy, t);

                    state.cytoscapeInstances.push(cy);
                }, 50);
            }
        }

        function regenerateGraphLayout() {
            // Cycle to next layout
            state.currentLayoutIndex = (state.currentLayoutIndex + 1) % layoutAlgorithms.length;
            const currentLayout = layoutAlgorithms[state.currentLayoutIndex];

            // Apply the new layout to all Cytoscape instances
            state.cytoscapeInstances.forEach((cy, index) => {
                if (cy) {
                    const layout = cy.layout(currentLayout.options);
                    layout.run();
                }
            });

            console.log(`Applied layout: ${currentLayout.name}`);
        }

        function updateNodeColors(cy, timestep) {
            cy.nodes().forEach(node => {
                const roomName = node.data('name');
                const placements = state.placements[timestep][roomName];

                // Build label with room name, optional headcount, and character initials
                let label = roomName;

                // Append headcount if provided for this room and timestep
                const roomCount = state.counts && state.counts[timestep] ? state.counts[timestep][roomName] : null;
                if (typeof roomCount === 'number' && roomCount >= 0) {
                    label += ` (${roomCount})`;
                }

                if (placements && placements.length > 0) {
                    const activeChars = placements.filter(p => !p.strikethrough);
                    const struckChars = placements.filter(p => p.strikethrough);

                    if (activeChars.length > 0 || struckChars.length > 0) {
                        label += '\n\n';

                        // Add active characters
                        if (activeChars.length > 0) {
                            label += activeChars.map(p => p.initial).join(' ');
                        }

                        // Add struck characters with strikethrough
                        if (struckChars.length > 0) {
                            if (activeChars.length > 0) label += ' ';
                            // Note: Cytoscape doesn't support text-decoration in labels
                            // So we'll use a different visual indicator
                            label += struckChars.map(p => `[${p.initial}]`).join(' ');
                        }
                    }

                    // Has characters - use first character's color
                    const firstChar = activeChars[0];
                    if (firstChar) {
                        node.style('border-color', firstChar.color);
                        node.style('border-width', 4);
                    } else {
                        node.style('border-color', '#ef4444');
                        node.style('border-width', 3);
                    }
                } else {
                    // Empty
                    node.style('border-color', '#9ca3af');
                    node.style('border-width', 3);
                }

                node.style('label', label);
            });
        }

        function showCharacterSelector(timestep, roomName, event) {
            const selector = document.getElementById('characterSelector');
            const header = document.getElementById('selectorHeader');
            const grid = document.getElementById('characterGrid');
            const existingChips = document.getElementById('existingChips');
            const backdrop = createBackdrop();

            state.currentSelector = { timestep, roomName };

            header.textContent = `${roomName} at Time ${timestep}`;

            // Render room count control
            const maxCount = state.characters.length;
            const existingCount = (state.counts && state.counts[timestep]) ? state.counts[timestep][roomName] : null;
            const roomCountDiv = document.getElementById('roomCount');
            if (roomCountDiv) {
                const initialVal = (existingCount === null || existingCount === undefined) ? '' : existingCount;
                roomCountDiv.innerHTML = `
                    <label for="roomCountInput">Characters present:</label>
                    <input type="number" id="roomCountInput" min="0" max="${maxCount}" placeholder="0" value="${initialVal}">
                `;
                const rcInput = document.getElementById('roomCountInput');
                rcInput.addEventListener('input', (e) => {
                    let val = e.target.value;
                    if (val === '') {
                        if (!state.counts[timestep]) state.counts[timestep] = {};
                        state.counts[timestep][roomName] = null;
                        updateMiniMapVisuals(timestep);
                        saveState();
                        return;
                    }
                    let num = parseInt(val, 10);
                    if (isNaN(num) || num < 0) num = 0;
                    const cap = state.characters.length;
                    if (num > cap) num = cap;
                    e.target.value = String(num);
                    if (!state.counts[timestep]) state.counts[timestep] = {};
                    state.counts[timestep][roomName] = num;
                    updateMiniMapVisuals(timestep);
                    saveState();
                });
            }

            // Render character options
            grid.innerHTML = '';
            state.characters.forEach(char => {
                const btn = document.createElement('button');
                btn.className = 'character-option';
                btn.style.borderColor = char.color;
                btn.innerHTML = `
                    <span class="initial" style="color: ${char.color}">${char.initial}</span>
                    <span class="name">${char.name}</span>
                `;
                btn.onclick = () => addCharacterChip(timestep, roomName, char);
                grid.appendChild(btn);
            });

            // Show existing chips and bulk actions
            const placements = state.placements[timestep][roomName] || [];
            existingChips.innerHTML = '';
            
            if (placements.length > 0) {
                existingChips.innerHTML = '<div style="font-size: 11px; font-weight: 600; margin-bottom: 8px;">Current:</div>';
                placements.forEach(placement => {
                    const chipItem = document.createElement('div');
                    chipItem.className = 'chip-item';
                    chipItem.innerHTML = `
                        <span style="color: ${placement.color}; font-weight: 600; ${placement.strikethrough ? 'text-decoration: line-through; text-decoration-thickness: 2px;' : ''}">${placement.initial}</span>
                        <span style="font-size: 11px; ${placement.strikethrough ? 'text-decoration: line-through; text-decoration-thickness: 2px;' : ''}">${placement.char}</span>
                        <button class="${placement.strikethrough ? 'strike' : ''}" onclick="toggleStrikethrough(${timestep}, '${roomName}', '${placement.char}', event)">
                            ${placement.strikethrough ? 'Unstrike' : 'Strike'}
                        </button>
                        <button onclick="removeCharacterChip(${timestep}, '${roomName}', '${placement.char}', event)">Remove</button>
                    `;
                    existingChips.appendChild(chipItem);
                });
            }

            // Always add Strike All / Unstrike All buttons (even if no placements yet)
            const bulkActions = document.createElement('div');
            bulkActions.style.cssText = 'display: flex; gap: 4px; margin-top: 8px; padding-top: 8px; border-top: 1px solid #e5e7eb;';
            bulkActions.innerHTML = `
                <button style="flex: 1; padding: 8px 12px; font-size: 12px; background: #ef4444; color: white; border: none; border-radius: 4px; cursor: pointer; min-height: 36px;" onclick="strikeAllChips(${timestep}, '${roomName}', event)">Strike All</button>
                <button style="flex: 1; padding: 8px 12px; font-size: 12px; background: #10b981; color: white; border: none; border-radius: 4px; cursor: pointer; min-height: 36px;" onclick="unstrikeAllChips(${timestep}, '${roomName}', event)">Unstrike All</button>
                <button style="flex: 1; padding: 8px 12px; font-size: 12px; background: #6b7280; color: white; border: none; border-radius: 4px; cursor: pointer; min-height: 36px;" onclick="removeAllChips(${timestep}, '${roomName}', event)">Remove All</button>
            `;
            existingChips.appendChild(bulkActions);

            // Position selector - center on mobile, near click on desktop
            if (window.innerWidth <= 768) {
                backdrop.style.display = 'block';
                selector.style.left = '50%';
                selector.style.top = '50%';
                selector.style.transform = 'translate(-50%, -50%)';
            } else {
                selector.style.left = `${event.pageX + 10}px`;
                selector.style.top = `${event.pageY + 10}px`;
                selector.style.transform = 'none';
            }

            selector.classList.remove('hidden');

            // Close on outside click
            setTimeout(() => {
                document.addEventListener('click', closeSelector);
                document.addEventListener('touchstart', closeSelector);
            }, 100);
        }

        function closeSelector(e) {
            const selector = document.getElementById('characterSelector');
            const backdrop = document.getElementById('selectorBackdrop');
            if (!selector.contains(e.target)) {
                selector.classList.add('hidden');
                if (backdrop) backdrop.style.display = 'none';
                document.removeEventListener('click', closeSelector);
                document.removeEventListener('touchstart', closeSelector);
            }
        }

        // Add backdrop overlay for mobile
        function createBackdrop() {
            let backdrop = document.getElementById('selectorBackdrop');
            if (!backdrop) {
                backdrop = document.createElement('div');
                backdrop.id = 'selectorBackdrop';
                backdrop.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 999; display: none;';
                backdrop.onclick = () => {
                    document.getElementById('characterSelector').classList.add('hidden');
                    backdrop.style.display = 'none';
                };
                document.body.appendChild(backdrop);
            }
            return backdrop;
        }

        function addCharacterChip(timestep, roomName, char) {
            // Check if already exists
            const existing = state.placements[timestep][roomName].find(p => p.char === char.name);
            if (existing) return;

            state.placements[timestep][roomName].push({
                char: char.name,
                initial: char.initial,
                color: char.color,
                strikethrough: false
            });

            updateMiniMapVisuals(timestep);
            saveState();

            // Refresh existing chips display without closing modal
            refreshExistingChips(timestep, roomName);
        }

        function toggleStrikethrough(timestep, roomName, charName, event) {
            if (event) event.stopPropagation();
            const placement = state.placements[timestep][roomName].find(p => p.char === charName);
            if (placement) {
                placement.strikethrough = !placement.strikethrough;
                updateMiniMapVisuals(timestep);
                saveState();

                // Refresh existing chips display without closing modal
                refreshExistingChips(timestep, roomName);
            }
        }

        function removeCharacterChip(timestep, roomName, charName, event) {
            if (event) event.stopPropagation();
            state.placements[timestep][roomName] = state.placements[timestep][roomName].filter(p => p.char !== charName);
            updateMiniMapVisuals(timestep);
            saveState();

            // Refresh existing chips display without closing modal
            refreshExistingChips(timestep, roomName);
        }

        function updateMiniMapVisuals(timestep) {
            const cyIndex = timestep - 1;
            if (state.cytoscapeInstances[cyIndex]) {
                updateNodeColors(state.cytoscapeInstances[cyIndex], timestep);
            }
        }

        function refreshExistingChips(timestep, roomName) {
            const existingChips = document.getElementById('existingChips');
            const placements = state.placements[timestep][roomName] || [];

            existingChips.innerHTML = '';
            
            if (placements.length > 0) {
                existingChips.innerHTML = '<div style="font-size: 11px; font-weight: 600; margin-bottom: 8px;">Current:</div>';
                placements.forEach(placement => {
                    const chipItem = document.createElement('div');
                    chipItem.className = 'chip-item';
                    chipItem.innerHTML = `
                        <span style="color: ${placement.color}; font-weight: 600; ${placement.strikethrough ? 'text-decoration: line-through; text-decoration-thickness: 2px;' : ''}">${placement.initial}</span>
                        <span style="font-size: 11px; ${placement.strikethrough ? 'text-decoration: line-through; text-decoration-thickness: 2px;' : ''}">${placement.char}</span>
                        <button class="${placement.strikethrough ? 'strike' : ''}" onclick="toggleStrikethrough(${timestep}, '${roomName}', '${placement.char}', event)">
                            ${placement.strikethrough ? 'Unstrike' : 'Strike'}
                        </button>
                        <button onclick="removeCharacterChip(${timestep}, '${roomName}', '${placement.char}', event)">Remove</button>
                    `;
                    existingChips.appendChild(chipItem);
                });
            }

            // Always add Strike All / Unstrike All / Remove All buttons (even if no placements yet)
            const bulkActions = document.createElement('div');
            bulkActions.style.cssText = 'display: flex; gap: 4px; margin-top: 8px; padding-top: 8px; border-top: 1px solid #e5e7eb;';
            bulkActions.innerHTML = `
                <button style="flex: 1; padding: 8px 12px; font-size: 12px; background: #ef4444; color: white; border: none; border-radius: 4px; cursor: pointer; min-height: 36px;" onclick="strikeAllChips(${timestep}, '${roomName}', event)">Strike All</button>
                <button style="flex: 1; padding: 8px 12px; font-size: 12px; background: #10b981; color: white; border: none; border-radius: 4px; cursor: pointer; min-height: 36px;" onclick="unstrikeAllChips(${timestep}, '${roomName}', event)">Unstrike All</button>
                <button style="flex: 1; padding: 8px 12px; font-size: 12px; background: #6b7280; color: white; border: none; border-radius: 4px; cursor: pointer; min-height: 36px;" onclick="removeAllChips(${timestep}, '${roomName}', event)">Remove All</button>
            `;
            existingChips.appendChild(bulkActions);
        }

        function strikeAllChips(timestep, roomName, event) {
            if (event) event.stopPropagation();
            
            // Add all characters to this room if not already present, then strike them all
            state.characters.forEach(char => {
                const existing = state.placements[timestep][roomName].find(p => p.char === char.name);
                if (existing) {
                    existing.strikethrough = true;
                } else {
                    // Add the character with strikethrough
                    state.placements[timestep][roomName].push({
                        char: char.name,
                        initial: char.initial,
                        color: char.color,
                        strikethrough: true
                    });
                }
            });
            
            updateMiniMapVisuals(timestep);
            saveState();
            refreshExistingChips(timestep, roomName);
        }

        function unstrikeAllChips(timestep, roomName, event) {
            if (event) event.stopPropagation();
            
            // Add all characters to this room if not already present, then unstrike them all
            state.characters.forEach(char => {
                const existing = state.placements[timestep][roomName].find(p => p.char === char.name);
                if (existing) {
                    existing.strikethrough = false;
                } else {
                    // Add the character without strikethrough
                    state.placements[timestep][roomName].push({
                        char: char.name,
                        initial: char.initial,
                        color: char.color,
                        strikethrough: false
                    });
                }
            });
            
            updateMiniMapVisuals(timestep);
            saveState();
            refreshExistingChips(timestep, roomName);
        }

        function removeAllChips(timestep, roomName, event) {
            if (event) event.stopPropagation();
            
            // Remove all characters from this room at this timestep
            state.placements[timestep][roomName] = [];
            
            updateMiniMapVisuals(timestep);
            saveState();
            refreshExistingChips(timestep, roomName);
        }

        function strikeAllEverywhere() {
            if (!confirm('This will add all characters to every room at every timestep with strikethrough. This action can be undone. Continue?')) {
                return;
            }

            // Iterate through all timesteps and rooms
            for (let t = 1; t <= state.timesteps; t++) {
                state.rooms.forEach(room => {
                    // Add all characters with strikethrough
                    state.characters.forEach(char => {
                        const existing = state.placements[t][room].find(p => p.char === char.name);
                        if (existing) {
                            existing.strikethrough = true;
                        } else {
                            state.placements[t][room].push({
                                char: char.name,
                                initial: char.initial,
                                color: char.color,
                                strikethrough: true
                            });
                        }
                    });
                });

                // Update visuals for this timestep
                updateMiniMapVisuals(t);
            }

            saveState();
            alert('All characters have been struck through for all rooms and times.');
        }

        function renderTrackingTable() {
            const table = document.getElementById('trackingTable');

            let html = '<thead><tr><th>Character</th>';
            state.rooms.forEach(room => {
                html += `<th>${room}</th>`;
            });
            html += '</tr></thead><tbody>';

            state.characters.forEach(char => {
                html += `<tr><td class="character-name">${char.name}</td>`;
                state.rooms.forEach(room => {
                    html += `<td><input type="number" min="0" max="${state.timesteps}" placeholder="0" data-char="${char.name}" data-room="${room}"></td>`;
                });
                html += '</tr>';
            });

            html += '</tbody>';
            table.innerHTML = html;

            // Add event listeners to tracking table inputs
            const inputs = document.querySelectorAll('.tracking-table input');
            inputs.forEach(input => {
                input.addEventListener('input', () => {
                    saveToLocalStorage();
                });
            });
        }

        // Undo/Redo functionality
        function saveState() {
            const stateSnapshot = JSON.stringify({
                placements: state.placements,
                counts: state.counts,
                notes: document.getElementById('notesEditor').value
            });

            // Remove any states after current index
            state.history = state.history.slice(0, state.historyIndex + 1);
            state.history.push(stateSnapshot);
            state.historyIndex++;

            // Limit history to 50 states
            if (state.history.length > 50) {
                state.history.shift();
                state.historyIndex--;
            }

            updateUndoRedoButtons();

            // Save to localStorage
            saveToLocalStorage();
        }

        function undo() {
            if (state.historyIndex > 0) {
                state.historyIndex--;
                restoreState(state.history[state.historyIndex]);
                updateUndoRedoButtons();
            }
        }

        function redo() {
            if (state.historyIndex < state.history.length - 1) {
                state.historyIndex++;
                restoreState(state.history[state.historyIndex]);
                updateUndoRedoButtons();
            }
        }

        function restoreState(stateStr) {
            const snapshot = JSON.parse(stateStr);
            state.placements = snapshot.placements;
            state.counts = snapshot.counts || {};
            document.getElementById('notesEditor').value = snapshot.notes;

            // Update all mini-maps
            for (let t = 1; t <= state.timesteps; t++) {
                updateMiniMapVisuals(t);
            }
        }

        function updateUndoRedoButtons() {
            const canUndo = state.historyIndex > 0;
            const canRedo = state.historyIndex < state.history.length - 1;

            document.getElementById('undoBtn').disabled = !canUndo;
            document.getElementById('redoBtn').disabled = !canRedo;
            document.getElementById('floatingUndo').disabled = !canUndo;
            document.getElementById('floatingRedo').disabled = !canRedo;
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
                e.preventDefault();
                undo();
            } else if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {
                e.preventDefault();
                redo();
            }
        });

        // Notes formatting
        function formatText(command) {
            const editor = document.getElementById('notesEditor');
            const start = editor.selectionStart;
            const end = editor.selectionEnd;
            const selectedText = editor.value.substring(start, end);

            // Simple markdown-style formatting
            let formatted = selectedText;
            switch(command) {
                case 'bold':
                    formatted = `**${selectedText}**`;
                    break;
                case 'italic':
                    formatted = `*${selectedText}*`;
                    break;
                case 'underline':
                    formatted = `__${selectedText}__`;
                    break;
            }

            editor.value = editor.value.substring(0, start) + formatted + editor.value.substring(end);
            editor.focus();
            editor.setSelectionRange(start, start + formatted.length);
        }

        function insertBullet() {
            const editor = document.getElementById('notesEditor');
            const start = editor.selectionStart;
            const bullet = '\n• ';
            editor.value = editor.value.substring(0, start) + bullet + editor.value.substring(start);
            editor.focus();
            editor.setSelectionRange(start + bullet.length, start + bullet.length);
        }

        // Auto-save notes
        document.getElementById('notesEditor').addEventListener('input', () => {
            saveState();
        });

        // Initialize on load
        window.addEventListener('load', () => {
            // Try to restore from localStorage first
            const restored = loadFromLocalStorage();

            // If nothing was restored, initialize with defaults
            if (!restored) {
                initializeSheet();
            }
        });
    </script>
</body>
</html>
