<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Scenario Handler (Offline SAT)</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root { --bg:#0b0f14; --fg:#e6edf3; --muted:#9fb1c1; --accent:#4da3ff; --bad:#ff6b6b; --good:#42d392; --card:#121821; }
  * { box-sizing: border-box; }
  body { margin:0; background:var(--bg); color:var(--fg); font:14px/1.45 system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial; overflow-x:hidden; }
  header { padding:16px 20px; border-bottom:1px solid #18222f; display:flex; gap:16px; align-items:center; flex-wrap:wrap; }
  header h1 { margin:0; font-size:16px; letter-spacing:.5px; color:#cfe6ff; }
  .link-button { color:var(--fg); border:1px solid #253244; padding:8px 10px; border-radius:10px; text-decoration:none; background:#0e141b; }
  .link-button:hover { border-color:var(--accent); color:var(--accent); }
  .wrap { display:grid; grid-template-columns: 1fr; gap:16px; padding:16px; max-width:100vw; }
  @media (min-width: 1024px) {
    .wrap { grid-template-columns: 420px 1fr; }
  }
  .card { background:var(--card); border:1px solid #18222f; border-radius:12px; padding:12px; max-width:100%; overflow:hidden; }
  .card h2 { margin:0 0 8px; font-size:13px; color:#cfe6ff; letter-spacing:.4px; }
  textarea, input, select, button { font: inherit; box-sizing:border-box; }
  textarea { width:100%; max-width:100%; height:180px; background:#0e141b; color:var(--fg); border:1px solid #253244; border-radius:10px; padding:10px; box-sizing:border-box; }
  .row { display:flex; gap:8px; align-items:center; margin:6px 0; flex-wrap:wrap; }
  .row input[type="text"], .row input[type="number"], .row input[type="range"] { min-width:0; flex:1 1 auto; }
  #percentileValue { color:var(--muted); font-size:12px; min-width:48px; text-align:right; }
  .row label { color:var(--muted); font-size:12px; }
  .chips { display:flex; gap:6px; flex-wrap:wrap; }
  .chip { background:#0e141b; border:1px dashed #31455e; padding:6px 8px; border-radius:999px; }
  .pill { padding:4px 8px; border-radius:999px; font-size:12px; border:1px solid #253244; color:#d8e6f6; background:#0e141b; min-width:0; max-width:100%; }
  button.primary { background:var(--accent); color:#001122; border:none; padding:10px 14px; border-radius:10px; font-weight:600; cursor:pointer; white-space:nowrap; }
  button.ghost { background:#0e141b; color:var(--fg); border:1px solid #253244; padding:8px 10px; border-radius:10px; cursor:pointer; white-space:nowrap; }
  table { width:100%; border-collapse:collapse; white-space:nowrap; }
  .table-scroll { overflow-x:auto; max-width:100%; }
  th, td { border-bottom:1px solid #223146; padding:6px 8px; text-align:left; }
  th { color:#cfe6ff; font-weight:600; font-size:12px; }
  .muted { color:var(--muted); }
  .warn { color:var(--bad); }
  .ok { color:var(--good); }
  .tiny { font-size:12px; }
  .grid { display:grid; grid-template-columns: 1fr; gap:12px; }
  @media (min-width: 768px) {
    .grid { grid-template-columns: repeat(auto-fit, minmax(260px, 1fr)); }
  }
  .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; word-break:break-all; }
  pre { overflow-x:auto; max-width:100%; }
  .hint { color:#9fb1c1; font-size:12px; word-break:break-word; }
  .footer { padding:10px 16px; border-top:1px solid #18222f; color:#7ea2c7; font-size:11px; }
  @media (max-width: 640px) {
    header h1 { font-size:14px; }
    .hint { font-size:11px; }
    textarea { height:120px; font-size:13px; }
    button.primary, button.ghost { padding:8px 12px; font-size:13px; }
  }
  .question-interface { margin-top:16px; }
  .question-type { display:flex; gap:12px; margin-bottom:12px; flex-wrap:wrap; }
  .question-type button { flex:1; min-width:140px; }
  .question-form { display:none; }
  .question-form.active { display:block; }
  .answer-box { margin-top:12px; padding:12px; border-radius:8px; background:#0e141b; border:1px solid #253244; }
  .answer-shared { color:#42d392; font-weight:600; margin-bottom:8px; }
  .answer-private { color:#9fb1c1; font-size:12px; margin-top:8px; }
  .answer-private.hidden { filter: blur(8px); user-select: none; }
  .private-toggle { font-size:11px; padding:6px 12px; cursor:pointer; margin-top:8px; display:inline-block; }
  select.pill { padding:6px 10px; }
</style>
</head>
<body>
<header>
  <h1>Scenario Handler ‚Äî Offline SAT</h1>
  <a class="link-button" href="./scenario_handler_v2.html" rel="noopener">Try New UI (v2) ‚Üó</a>
  <a class="link-button" href="./digital-note-sheet.html" target="_blank" rel="noopener">Open Digital Note Taker ‚Üó</a>
  <span class="hint">Paste Mermaid-like graph, set constraints, then Generate.</span>
</header>

<div class="wrap">
  <section class="card">
    <h2>Map (Mermaid-like)</h2>
    <div class="hint tiny">Use undirected edges with <span class="mono">---</span>. Node IDs are room names (quote names with spaces).</div>
    <textarea id="mermaidInput">graph TD
  Foyer --- Stairs
  Foyer --- Gallery
  Gallery --- Stairs
  Gallery --- Masks
  Masks --- DanceRoom
  Masks --- MusicRoom
  MusicRoom --- DanceRoom</textarea>
    <div class="row">
      <label for="chars">Characters:</label>
      <input id="chars" class="pill" value="A, B, C, D, S, J" />
      <label for="steps">Timesteps (T):</label>
      <input id="steps" type="number" min="2" max="10" class="pill" value="6" />
    </div>
    <div class="row">
      <label>Movement:</label>
      <label><input type="checkbox" id="mustMove" checked /> Must move each time</label>
      <label><input type="checkbox" id="allowStay" /> Allow stay (overrides ‚Äúmust move‚Äù)</label>
    </div>
    <div class="row">
      <label for="seed">Seed:</label>
      <input id="seed" type="text" class="pill" placeholder="(blank = random)" />
      <button class="ghost" id="validateBtn">Validate Map</button>
    </div>

    <h2>Scenarios (Select One)</h2>
    <div class="row">
      <label><input type="radio" name="scenario" id="s1" value="s1" /> S1: Poison (assassin alone with victim, first char is assassin)</label>
    </div>
    <div class="row tiny">
      <label>Poison room (optional exact):</label>
      <input id="s1_room" class="pill" placeholder="e.g., Office" />
      <label>Poison time (1..T):</label>
      <input id="s1_time" class="pill" placeholder="e.g., 3" />
      <span class="muted tiny">(Assassin is always first character in list)</span>
    </div>
    <div class="row">
      <label><input type="radio" name="scenario" id="s2" value="s2" /> S2: Phantom (one character is alone at every time)</label>
    </div>
    <div class="row">
      <label><input type="radio" name="scenario" id="s3" value="s3" /> S3: Singer's Jewels (someone must enter the alphabetically first room)</label>
    </div>
    <div class="row">
      <label><input type="radio" name="scenario" id="s4" value="s4" /> S4: Bomb duo (two culprits are the <i>only pair ever alone together</i> and they must share a private meeting)</label>
    </div>
    <div class="row">
      <label><input type="radio" name="scenario" id="s5" value="s5" /> S5: Lovers (two lovers never meet; every pair of non-lovers must meet at least once)</label>
    </div>
    <div class="row">
      <label><input type="radio" name="scenario" id="s6" value="s6" /> S6: Phantom + Lovers (one phantom alone at every time, two separate lovers who never meet)</label>
    </div>
    <div class="row">
      <label><input type="radio" name="scenario" id="s7" value="s7" /> S7: Aggrosassin (serial poisoner who kills everyone they meet 1-on-1)</label>
    </div>
    <div class="row">
      <label><input type="radio" name="scenario" id="s8" value="s8" /> S8: The Freeze (identify Mr. Freeze and the frozen victims)</label>
    </div>
    <div class="row">
      <label><input type="radio" name="scenario" id="s9" value="s9" /> S9: Doctor's Cure (frozen victims thaw mid-game)</label>
    </div>
    <div class="row">
      <label><input type="radio" name="scenario" id="s10" value="s10" /> S10: Contagion (alphabetically first room infects entrants; track infection order)</label>
    </div>
    <div class="row">
      <label><input type="radio" name="scenario" id="s11" value="s11" /> S11: The Vault (only the key holder may enter the earliest room; deduce the holder and all entrants)</label>
    </div>
    <div class="row">
      <label><input type="radio" name="scenario" id="s12" value="s12" /> S12: Glue Room (identify the sticky room and each character's first entry time)</label>
    </div>
    <div class="row">
      <label><input type="radio" name="scenario" id="s13" value="s13" /> S13: Glue Shoes (identify the glue-shoed character and when each victim was first stuck)</label>
    </div>
    <div class="row">
      <label><input type="radio" name="scenario" id="s14" value="s14" /> S14: Curse of Amarinta (trace the original curse carrier)</label>
    </div>
    <div class="row">
      <label><input type="radio" name="scenario" id="s15" value="s15" /> S15: World Travelers (rank top 3 by rooms visited)</label>
    </div>

    <div class="row">
      <label>Difficulty percentile (0-100):</label>
      <input id="percentile" type="range" min="0" max="100" step="0.1" value="50" />
      <span id="percentileValue">50</span>
      <label>Samples:</label>
      <input id="samples" type="number" min="10" max="5000" class="pill" value="10" />
    </div>
    <div class="row">
      <button class="primary" id="genBtn">Generate</button>
      <button class="ghost" id="reuseBtn" disabled>Pick From Last Run</button>
      <span id="status" class="hint"></span>
    </div>
  </section>

  <section class="card">
    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
      <h2 style="margin:0;">Results</h2>
      <button class="ghost" id="toggleResultsBtn" style="display:none;">‚ñº Collapse</button>
    </div>
    <div id="resultsHint" class="hint tiny">No results yet.</div>
    <div id="results" style="display:none">
      <div class="grid">
        <div class="card">
          <h2>Schedule (Characters √ó Time)</h2>
          <div id="schedule"></div>
        </div>
        <div class="card">
          <h2>Counts by Time</h2>
          <div id="byTime"></div>
        </div>
        <div class="card">
          <h2>Visits</h2>
          <div id="visits"></div>
        </div>
        <div class="card">
          <h2>Private Facts</h2>
          <div id="privateFacts"></div>
        </div>
        <div class="card">
          <h2>Generation Statistics</h2>
          <div id="genStats" class="tiny"></div>
        </div>
        <div class="card">
          <h2>Scenario String</h2>
          <div class="hint tiny">This string encodes the entire scenario. Share it or bookmark the URL to recreate this exact scenario.</div>
          <textarea id="scenarioString" class="mono tiny" readonly style="height:80px; font-size:11px; resize:vertical;"></textarea>
          <div class="row" style="margin-top:8px;">
            <button class="ghost" id="copyScenarioBtn">üìã Copy String</button>
            <button class="ghost" id="copyURLBtn">üîó Copy URL</button>
          </div>
        </div>
      </div>
    </div>
  </section>

  <section class="card">
    <h2>Starting Information</h2>
    <div class="starting-info-interface">
      <div class="row">
        <label>Timestep:</label>
        <select id="startingTime" class="pill"></select>
        <label>Number of characters:</label>
        <input id="startingCharCount" type="number" min="1" max="10" class="pill" value="3" style="width:80px;" />
        <button class="primary" id="showStartingInfoBtn">Show Starting Positions</button>
      </div>
      <div id="startingInfoAnswer" class="answer-box" style="display:none;">
        <div class="answer-shared" id="startingInfoShared"></div>
      </div>
      <div id="startingInfoScenarioNote" class="hint tiny" style="display:none; margin-top:8px;"></div>
    </div>
  </section>

  <section class="card">
    <h2>Question Interface</h2>
    <div class="question-interface">
      <div class="question-type">
        <button class="ghost" id="askLocTimeBtn">Location + Time</button>
        <button class="ghost" id="askLocCharBtn">Location + Character</button>
      </div>
      
      <div id="locTimeForm" class="question-form">
        <div class="row">
          <label>Location:</label>
          <select id="locTimeLocation" class="pill"></select>
          <label>Time:</label>
          <select id="locTimeTime" class="pill"></select>
          <button class="primary" id="askLocTimeSubmit">Ask</button>
        </div>
        <div id="locTimeAnswer" class="answer-box" style="display:none;">
          <div class="answer-shared" id="locTimeShared"></div>
          <div>
            <button class="ghost private-toggle" id="locTimeToggle">üëÅÔ∏è Show</button>
          </div>
          <div class="answer-private hidden" id="locTimePrivate"></div>
        </div>
      </div>
      
      <div id="locCharForm" class="question-form">
        <div class="row">
          <label>Location:</label>
          <select id="locCharLocation" class="pill"></select>
          <label>Character:</label>
          <select id="locCharChar" class="pill"></select>
          <button class="primary" id="askLocCharSubmit">Ask</button>
        </div>
        <div id="locCharAnswer" class="answer-box" style="display:none;">
          <div class="answer-shared" id="locCharShared"></div>
          <div>
            <button class="ghost private-toggle" id="locCharToggle">üëÅÔ∏è Show</button>
          </div>
          <div class="answer-private hidden" id="locCharPrivate"></div>
        </div>
      </div>
    </div>
  </section>
</div>

<div class="footer tiny">SAT core: DPLL + unit propagation (pure JS). Scenarios: S1 (Poison), S2 (Phantom + non-isolation), S3 (Singer's Jewels), S4 (Bomb Duo ‚Äì only pair allowed alone, and it happens at least once), S5 (Lovers + all non-lovers meet), S6 (Phantom + Lovers), S7 (Aggrosassin - serial poisoner), S8 (The Freeze - victims frozen in place), S9 (Doctor's Cure - thaw frozen victims mid-game), S10 (Contagion - infection chain from the first alphabetical room), S11 (The Vault - alphabetically first room locked to the key holder), S12 (Glue Room - sticky room forces two-turn visits), S13 (Glue Shoes - glue carrier makes co-occupants stay an extra turn), S14 (Curse of Amarinta - curse handoffs to deduce the origin).</div>

<script type="module">
/* ===========================
   Import from scenario-solver.js
   =========================== */
import {
  parseMermaid,
  neighbors,
  buildCNF,
  solveAndDecode
} from './src/scenario-solver.js';
import {
  clampPercentile,
  decodeScenarioFromURL,
  deriveGlueRoomFacts,
  deriveGlueShoesFacts,
  encodeScenarioToURL,
  getScenarioFromURL,
  scoreScenario,
  updateURL
} from './src/scenario-shared.js';


/* ===========================
   UI glue
   =========================== */
function qs(id){ return document.getElementById(id); }
let lastRun = null;

// Start with a blank seed so repeated generations default to fresh randomness
qs("seed").value = "";

function syncPercentileDisplay() {
  const slider = qs("percentile");
  const display = qs("percentileValue");
  const pct = clampPercentile(Number(slider.value));
  slider.value = pct;
  if (display) display.textContent = pct.toFixed(1);
}

function wireCopyButtons(encoded) {
  qs("scenarioString").value = encoded;

  qs("copyScenarioBtn").onclick = ()=>{
    navigator.clipboard.writeText(encoded).then(()=>{
      const btn = qs("copyScenarioBtn");
      const orig = btn.textContent;
      btn.textContent = "‚úì Copied!";
      setTimeout(()=> btn.textContent = orig, 2000);
    });
  };

  qs("copyURLBtn").onclick = ()=>{
    navigator.clipboard.writeText(window.location.href).then(()=>{
      const btn = qs("copyURLBtn");
      const orig = btn.textContent;
      btn.textContent = "‚úì Copied!";
      setTimeout(()=> btn.textContent = orig, 2000);
    });
  };
}

function updateStartingInfoNote(res, cfg) {
  const noteEl = qs("startingInfoScenarioNote");
  const curseInfo = res?.priv?.curse_of_amarinta;

  if (noteEl && cfg?.scenarios?.s14 && curseInfo) {
    const cursedAtSix = curseInfo.final_cursed || [];
    const cursedLabel = cursedAtSix.length ? cursedAtSix.join(', ') : 'no one';
    const verb = cursedAtSix.length === 1 ? 'is' : 'are';

    noteEl.innerHTML = `üßø Scenario 14 clue: <b>${cursedLabel}</b> ${verb} cursed at t=6.`;
    noteEl.style.display = "block";
  } else if (noteEl) {
    noteEl.textContent = "";
    noteEl.style.display = "none";
  }
}

function renderSelectedScenario({ res, cfg, percentile, sampleCount, skipped, solutions, targetIdx, source }) {
  const encoded = encodeScenarioToURL(res, cfg);
  updateURL(encoded);

  const label = source === 'reuse' ? 'Reused' : 'Selected';
  qs("status").innerHTML = `<span class="ok">${label} ${percentile}th percentile scenario</span> (score: ${res.score.total.toFixed(1)}, rank ${targetIdx+1}/${solutions.length}, ${skipped} skipped)`;
  qs("resultsHint").style.display = "none";
  qs("results").style.display = "block";
  qs("toggleResultsBtn").style.display = "inline-block";
  renderTable("schedule", res.schedule, "Character");
  renderTable("byTime", res.byTime, "Time");
  renderTable("visits", res.visits, "Character");
  updateStartingInfoNote(res, cfg);

  const pf = [];
  if (res.priv.phantom) pf.push(`<div>Phantom: <b>${res.priv.phantom}</b></div>`);
  if (res.priv.lovers) pf.push(`<div>Lovers: <b>${res.priv.lovers[0]}</b> + <b>${res.priv.lovers[1]}</b></div>`);
  if (res.priv.assassin) pf.push(`<div>Assassin: <b>${res.priv.assassin}</b> poisoned <b>${res.priv.victim}</b> @ t=${res.priv.poison_time}, room=${res.priv.poison_room}</div>`);
  if (res.priv.bomb_duo) pf.push(`<div>Bomb duo: <b>${res.priv.bomb_duo[0]}</b> + <b>${res.priv.bomb_duo[1]}</b></div>`);
  if (res.priv.aggrosassin) pf.push(`<div>Aggrosassin: <b>${res.priv.aggrosassin}</b> killed <b>${res.priv.victims.length}</b> victim${res.priv.victims.length === 1 ? '' : 's'}: ${res.priv.victims.join(', ')}</div>`);
  if (res.priv.freeze) {
    const victims = res.priv.freeze_victims || [];
    const kills = res.priv.freeze_kills || [];
    let detail = '';
    if (victims.length) {
      const killSummary = kills.map(k => `${k.victim} @ t=${k.time}, ${k.room}`).join('; ');
      detail = ` froze <b>${victims.length}</b> victim${victims.length === 1 ? '' : 's'}: ${victims.join(', ')}`;
      if (killSummary) {
        detail += ` (first freezes: ${killSummary})`;
      }
    }
    pf.push(`<div>Mr. Freeze: <b>${res.priv.freeze}</b>${detail}</div>`);
  }
  if (res.priv.doctor) {
    const frozen = res.priv.frozen || [];
    const heals = res.priv.heals || [];
    const frozenLabel = frozen.length ? `; frozen at start: ${frozen.join(', ')}` : '';
    const healLabel = heals.length
      ? `; heals: ${heals.map(h => `${h.character} @ t=${h.time}, ${h.room}`).join('; ')}`
      : '';
    pf.push(`<div>Doctor: <b>${res.priv.doctor}</b>${frozenLabel}${healLabel}</div>`);
  }
  if (res.priv.contagion) {
    const info = res.priv.contagion;
    const infectedList = (info.infection_order || []).map(ch => `${ch} (t=${info.infection_times?.[ch]})`);
    const infectedLabel = infectedList.length ? infectedList.join(', ') : 'No infections recorded';
    const neverInfected = (info.never_infected || []).join(', ');
    const neverLabel = neverInfected ? `; never infected: ${neverInfected}` : '';
    pf.push(`<div>Contagion: contagious room <b>${info.contagious_room}</b>; infected: ${infectedLabel}${neverLabel}</div>`);
  }
  if (res.priv.vault) {
    const info = res.priv.vault;
    const visitors = info.vault_visitors?.length ? info.vault_visitors.join(', ') : 'No entrants';
    pf.push(
      `<div>Vault: key holder <b>${info.key_holder}</b>; entrants: ${visitors}; vault room: ${info.vault_room}</div>`,
    );
  }
  const glueRoomPriv = res.priv.glue_room || deriveGlueRoomFacts(res, cfg);
  if (glueRoomPriv) {
    const info = glueRoomPriv;
    const entries = Object.entries(info.first_entries || {})
      .filter(([, t]) => t !== null)
      .map(([ch, t]) => `${ch} @ t=${t}`);
    const entryLabel = entries.length ? entries.join(', ') : 'No recorded entries before final timestep';
    pf.push(`
      <div>Glue Room: sticky room <b>${info.glue_room}</b>; first entries: ${entryLabel}</div>
    `);
  }
  const glueShoesPriv = res.priv.glue_shoes || deriveGlueShoesFacts(res, cfg);
  if (glueShoesPriv) {
    const info = glueShoesPriv;
    const stuck = info.stuck || [];
    const stuckLabel = stuck.length
      ? stuck.map((s) => `${s.character} @ t=${s.time}, ${s.room}`).join('; ')
      : 'No one stuck';
    pf.push(`Glue Shoes: carrier <b>${info.glue_person}</b>; stuck victims: ${stuckLabel}`);
  }
  if (res.priv.curse_of_amarinta) {
    const info = res.priv.curse_of_amarinta;
    const finalList = info.final_cursed?.length ? info.final_cursed.join(', ') : 'No one cursed at t=6';
    const possibles = info.possible_origins?.length ? info.possible_origins.join(', ') : 'n/a';
    pf.push(
      `Curse of Amarinta: starting carrier <b>${info.origin}</b>; cursed @ t=6: ${finalList}; possible origins from t=6 state: ${possibles}`,
    );
  }
  if (pf.length===0) pf.push(`<div class="muted">None</div>`);
  qs("privateFacts").innerHTML = pf.join("");

  const stats = res.stats || {};
  const avgSolveTime = solutions.reduce((sum, s) => sum + (s.stats?.solveTimeMs || 0), 0) / solutions.length;
  const statsHtml = `
      <div style="display: grid; grid-template-columns: auto 1fr; gap: 4px 12px;">
        <span class="muted">SAT Variables:</span>
        <span><b>${stats.totalVars}</b></span>

        <span class="muted">SAT Clauses:</span>
        <span><b>${stats.totalClauses}</b></span>

        <span class="muted">Avg Clause Length:</span>
        <span><b>${stats.avgClauseLength?.toFixed(2)}</b> literals</span>

        <span class="muted">Solve Time (this):</span>
        <span><b>${stats.solveTimeMs}</b>ms</span>

        <span class="muted">Avg Solve Time:</span>
        <span><b>${avgSolveTime.toFixed(1)}</b>ms</span>

        <span class="muted">Valid Solutions:</span>
        <span><b>${solutions.length}</b> / ${sampleCount} (${((solutions.length/sampleCount)*100).toFixed(1)}%)</span>

        <span class="muted">Difficulty Score:</span>
        <span><b>${res.score.total.toFixed(1)}</b> (${percentile}th percentile)</span>

        <span class="muted">Score Breakdown:</span>
        <span>${Object.entries(res.score.breakdown).map(([k,v]) => `${k}: ${v.toFixed(0)}`).join(', ') || 'N/A'}</span>
      </div>
    `;
  qs("genStats").innerHTML = statsHtml;

  wireCopyButtons(encoded);

  setupQuestionInterface(res, cfg);
}
function renderTable(container, obj, headerLeft){
  const el = typeof container==="string"? qs(container) : container;
  let html = "<div class='table-scroll'><table><thead><tr>";
  if (headerLeft) html += `<th>${headerLeft}</th>`;
  const keys = Object.keys(obj);
  const isArrayRows = Array.isArray(obj[keys[0]]);
  const cols = isArrayRows ? obj[keys[0]].length : Object.keys(obj[keys[0]] || {}).length;
  if (isArrayRows){
    for (let i=0;i<cols;i++) html += `<th>t=${i+1}</th>`;
    html += "</tr></thead><tbody>";
    for (const rowKey of keys){
      html += `<tr><th>${rowKey}</th>`;
      for (const val of obj[rowKey]) html += `<td>${val}</td>`;
      html += `</tr>`;
    }
  } else {
    const subkeys = Object.keys(obj[keys[0]]||{});
    for (const sk of subkeys) html += `<th>${sk}</th>`;
    html += "</tr></thead><tbody>";
    for (const rowKey of keys){
      html += `<tr><th>${rowKey}</th>`;
      for (const sk of subkeys) html += `<td>${obj[rowKey][sk]}</td>`;
      html += `</tr>`;
    }
  }
  html += "</tbody></table></div>";
  el.innerHTML = html;
}

qs("validateBtn").addEventListener("click", ()=>{
  const {rooms, edges} = parseMermaid(qs("mermaidInput").value);
  const msg = (rooms.length>=2 && edges.length>=1)
    ? `<span class="ok">OK:</span> ${rooms.length} rooms, ${edges.length} doors`
    : `<span class="warn">Need ‚â•2 rooms and ‚â•1 door.</span>`;
  qs("status").innerHTML = msg;
});

qs("percentile").addEventListener("input", syncPercentileDisplay);
syncPercentileDisplay();

qs("genBtn").addEventListener("click", async ()=>{
  const percentile = clampPercentile(Number(qs("percentile").value));
  const sampleCount = Number(qs("samples").value) || 100;
  const difficulty = percentile / 100;
  const s9FrozenRatio = 0.2 + (1 - difficulty) * 0.5;

  qs("status").textContent = `Generating ${sampleCount} scenarios‚Ä¶`;

  const {rooms, edges} = parseMermaid(qs("mermaidInput").value);
  const chars = qs("chars").value.split(",").map(s=>s.trim()).filter(Boolean);
  const T = Math.max(2, Math.min(10, Number(qs("steps").value)||6));
  const mustMove = qs("mustMove").checked;
  const allowStay = qs("allowStay").checked;

  if (rooms.length<2 || edges.length<1){ qs("status").innerHTML = `<span class="warn">Map too small.</span>`; return; }
  if (chars.length<2){ qs("status").innerHTML = `<span class="warn">Add at least 2 characters.</span>`; return; }

  // Get selected scenario (radio button)
  const selectedScenario = document.querySelector('input[name="scenario"]:checked');
  const scenarioValue = selectedScenario ? selectedScenario.value : null;

  if (!scenarioValue) {
    qs("status").innerHTML = `<span class="warn">Please select a scenario.</span>`;
    return;
  }

  const cfg = {
    rooms, edges, chars, T, mustMove, allowStay,
    scenarios: {
      s1: scenarioValue === 's1',
      s2: scenarioValue === 's2' || scenarioValue === 's6',
      s3: scenarioValue === 's3',
      s4: scenarioValue === 's4',
      s5: scenarioValue === 's5' || scenarioValue === 's6',
      s7: scenarioValue === 's7',
      s8: scenarioValue === 's8',
      s9: scenarioValue === 's9',
      s9FrozenRatio,
      s10: scenarioValue === 's10',
      s11: scenarioValue === 's11',
      s12: scenarioValue === 's12',
      s13: scenarioValue === 's13',
      s14: scenarioValue === 's14',
      s15: scenarioValue === 's15',
      s1_room: qs("s1_room").value.trim() || null,
      s1_time: qs("s1_time").value.trim() || null
    }
  };

  try{
    const solutions = [];
    let skipped = 0;
    const randomSeed = () => {
      if (typeof crypto !== "undefined" && crypto.getRandomValues) {
        return crypto.getRandomValues(new Uint32Array(1))[0];
      }
      return Math.floor(Math.random() * 0xffffffff) >>> 0;
    };

    const seedInput = qs("seed").value.trim();
    const parsedSeed = Number(seedInput);
    const fixedSeed = seedInput === "" || !Number.isFinite(parsedSeed)
      ? null
      : parsedSeed;

    for (let i = 0; i < sampleCount; i++) {
      cfg.seed = fixedSeed === null ? randomSeed() : fixedSeed + i;
      try {
        const res = solveAndDecode(cfg);
        if (res) {
          const scored = { ...res, score: scoreScenario(res, cfg) };
          solutions.push(scored);
        } else {
          skipped++;
        }
      } catch (e) {
        skipped++;
        console.warn(`Sample ${i} failed:`, e.message);
      }

      if (i % 10 === 0) {
        qs("status").textContent = `Generated ${i}/${sampleCount} (${solutions.length} valid, ${skipped} skipped)...`;
        await new Promise(r => setTimeout(r, 0));
      }
    }

    if (solutions.length === 0) {
      qs("status").innerHTML = `<span class="warn">No solutions found (${skipped} samples timed out or failed).</span>`;
      return;
    }

    solutions.sort((a, b) => a.score.total - b.score.total);

    lastRun = { solutions, skipped, sampleCount, cfg };
    qs("reuseBtn").disabled = false;

    const targetIdx = Math.floor((percentile / 100) * (solutions.length - 1));
    const res = solutions[targetIdx];

    renderSelectedScenario({ res, cfg, percentile, sampleCount, skipped, solutions, targetIdx, source: 'generate' });
  }catch(e){
    console.error(e);
    qs("status").innerHTML = `<span class="warn">Error: ${e.message}</span>`;
  }
});

qs("reuseBtn").addEventListener("click", ()=>{
  if (!lastRun) {
    qs("status").innerHTML = `<span class="warn">Generate at least once before reusing results.</span>`;
    return;
  }
  const pct = clampPercentile(Number(qs("percentile").value));
  const { solutions, skipped, sampleCount, cfg } = lastRun;
  const targetIdx = Math.floor((pct / 100) * (solutions.length - 1));
  const res = solutions[targetIdx];
  renderSelectedScenario({ res, cfg, percentile: pct, sampleCount, skipped, solutions, targetIdx, source: 'reuse' });
});

function setupQuestionInterface(res, cfg){
  const rooms = cfg.rooms;
  const chars = cfg.chars;
  const T = cfg.T;

  // Populate dropdowns
  const locTimeLocation = qs("locTimeLocation");
  const locCharLocation = qs("locCharLocation");
  const locCharChar = qs("locCharChar");
  const locTimeTime = qs("locTimeTime");
  const startingTime = qs("startingTime");

  locTimeLocation.innerHTML = rooms.map(r => `<option value="${r}">${r}</option>`).join("");
  locCharLocation.innerHTML = rooms.map(r => `<option value="${r}">${r}</option>`).join("");
  locCharChar.innerHTML = chars.map(c => `<option value="${c}">${c}</option>`).join("");
  locTimeTime.innerHTML = Array.from({length:T}, (_,i) => `<option value="${i+1}">t=${i+1}</option>`).join("");
  startingTime.innerHTML = Array.from({length:T}, (_,i) => `<option value="${i+1}"${i===0?' selected':''}>t=${i+1}</option>`).join("");

  // Toggle between question types
  qs("askLocTimeBtn").onclick = ()=>{
    qs("locTimeForm").classList.add("active");
    qs("locCharForm").classList.remove("active");
    qs("locTimeAnswer").style.display = "none";
  };
  qs("askLocCharBtn").onclick = ()=>{
    qs("locCharForm").classList.add("active");
    qs("locTimeForm").classList.remove("active");
    qs("locCharAnswer").style.display = "none";
  };

  // Location + Time question
  qs("askLocTimeSubmit").onclick = ()=>{
    const location = locTimeLocation.value;
    const time = Number(locTimeTime.value);
    
    // Count how many characters were in this location at this time
    const charsAtLocation = [];
    for (const char of chars){
      if (res.schedule[char][time-1] === location){
        charsAtLocation.push(char);
      }
    }
    
    const count = charsAtLocation.length;
    
    // Deterministically pick one character to reveal (based on location + time hash)
    let revealedChar = "none";
    if (count > 0) {
      // Simple hash: sum char codes of location + time
      let hash = time;
      for (let i = 0; i < location.length; i++) {
        hash = (hash * 31 + location.charCodeAt(i)) & 0x7fffffff;
      }
      const idx = hash % charsAtLocation.length;
      revealedChar = charsAtLocation[idx];
    }
    
    qs("locTimeShared").innerHTML = `üü¢ Shared: <b>${count}</b> character${count===1?'':'s'} ${count===1?'was':'were'} in ${location} at t=${time}`;
    qs("locTimePrivate").innerHTML = `‚ö™ Private: One character present: <b>${revealedChar}</b>`;
    qs("locTimePrivate").classList.add("hidden");
    qs("locTimeToggle").textContent = "üëÅÔ∏è Show";
    qs("locTimeAnswer").style.display = "block";
    
    // Setup toggle handler
    qs("locTimeToggle").onclick = ()=>{
      const privateEl = qs("locTimePrivate");
      const btn = qs("locTimeToggle");
      if (privateEl.classList.contains("hidden")) {
        privateEl.classList.remove("hidden");
        btn.textContent = "üëÅÔ∏è Hide";
      } else {
        privateEl.classList.add("hidden");
        btn.textContent = "üëÅÔ∏è Show";
      }
    };
  };

  // Location + Character question
  qs("askLocCharSubmit").onclick = ()=>{
    const location = locCharLocation.value;
    const character = locCharChar.value;
    
    // Count how many times this character visited this location
    const visitCount = res.visits[character][location] || 0;
    
    // Find which times they visited
    const times = [];
    for (let t=0; t<T; t++){
      if (res.schedule[character][t] === location){
        times.push(t+1);
      }
    }
    
    // Deterministically pick one time to reveal (based on location + character hash)
    let revealedTime = "never";
    if (times.length > 0) {
      // Simple hash: sum char codes of location + character
      let hash = 0;
      for (let i = 0; i < location.length; i++) {
        hash = (hash * 31 + location.charCodeAt(i)) & 0x7fffffff;
      }
      for (let i = 0; i < character.length; i++) {
        hash = (hash * 31 + character.charCodeAt(i)) & 0x7fffffff;
      }
      const idx = hash % times.length;
      revealedTime = `t=${times[idx]}`;
    }
    
    qs("locCharShared").innerHTML = `üü¢ Shared: <b>${visitCount}</b> visit${visitCount===1?'':'s'} by ${character} to ${location}`;
    qs("locCharPrivate").innerHTML = `‚ö™ Private: One time visited: <b>${revealedTime}</b>`;
    qs("locCharPrivate").classList.add("hidden");
    qs("locCharToggle").textContent = "üëÅÔ∏è Show";
    qs("locCharAnswer").style.display = "block";
    
    // Setup toggle handler
    qs("locCharToggle").onclick = ()=>{
      const privateEl = qs("locCharPrivate");
      const btn = qs("locCharToggle");
      if (privateEl.classList.contains("hidden")) {
        privateEl.classList.remove("hidden");
        btn.textContent = "üëÅÔ∏è Hide";
      } else {
        privateEl.classList.add("hidden");
        btn.textContent = "üëÅÔ∏è Show";
      }
    };
  };

  // Starting Information handler
  qs("showStartingInfoBtn").onclick = ()=>{
    const time = Number(startingTime.value);
    const charCount = Math.min(chars.length, Math.max(1, Number(qs("startingCharCount").value) || 3));
    
    // Deterministically select characters based on time (for consistency)
    // Use a simple hash to pick characters
    let hash = time * 7919; // Prime number for better distribution
    const selectedChars = [];
    const availableChars = [...chars];
    
    for (let i = 0; i < charCount && availableChars.length > 0; i++) {
      hash = (hash * 31 + i) & 0x7fffffff;
      const idx = hash % availableChars.length;
      selectedChars.push(availableChars[idx]);
      availableChars.splice(idx, 1);
    }
    
    // Get locations for selected characters at the specified time
    const locations = selectedChars.map(char => {
      const location = res.schedule[char][time-1];
      return `<b>${char}</b>: ${location}`;
    });
    
    qs("startingInfoShared").innerHTML = `üü¢ At t=${time}, the following character locations are revealed:<br/><br/>` + locations.join('<br/>');
    qs("startingInfoAnswer").style.display = "block";
  };

  // Default to Location + Time
  qs("askLocTimeBtn").click();
}

// Toggle results collapse/expand
qs("toggleResultsBtn").addEventListener("click", ()=>{
  const resultsDiv = qs("results");
  const btn = qs("toggleResultsBtn");
  if (resultsDiv.style.display === "none") {
    resultsDiv.style.display = "block";
    btn.textContent = "‚ñº Collapse";
  } else {
    resultsDiv.style.display = "none";
    btn.textContent = "‚ñ∂ Expand";
  }
});

// Load scenario from URL on page load
window.addEventListener('DOMContentLoaded', ()=>{
  const encoded = getScenarioFromURL();
  if (encoded) {
    const decoded = decodeScenarioFromURL(encoded);
    if (decoded) {
      // Populate form fields
      const mermaidLines = ['graph TD'];
      decoded.edges.forEach(([a, b]) => {
        const aQuoted = a.includes(' ') ? `"${a}"` : a;
        const bQuoted = b.includes(' ') ? `"${b}"` : b;
        mermaidLines.push(`  ${aQuoted} --- ${bQuoted}`);
      });
      qs("mermaidInput").value = mermaidLines.join('\n');
      qs("chars").value = decoded.chars.join(', ');
      qs("steps").value = decoded.T;
      qs("seed").value = decoded.seed;
      
      // Display the scenario
      qs("status").innerHTML = `<span class="ok">Loaded scenario from URL</span>`;
      qs("resultsHint").style.display = "none";
      qs("results").style.display = "block";
      qs("toggleResultsBtn").style.display = "inline-block";
      
      renderTable("schedule", decoded.schedule, "Character");
      renderTable("byTime", decoded.byTime, "Time");
      renderTable("visits", decoded.visits, "Character");
      
      // Note: We don't have private facts in the URL encoding (by design - they're secret!)
      qs("privateFacts").innerHTML = `<div class="muted">Private facts not included in URL (generate to see them)</div>`;
      
      wireCopyButtons(encoded);
      
      // Setup question interface with the decoded scenario
      const cfg = {
        rooms: decoded.rooms,
        chars: decoded.chars,
        T: decoded.T,
        edges: decoded.edges
      };
      setupQuestionInterface(decoded, cfg);
    } else {
      qs("status").innerHTML = `<span class="warn">Failed to load scenario from URL</span>`;
    }
  }
});
</script>
</body>
</html>
