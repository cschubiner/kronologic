<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Scenario Handler (Offline SAT)</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root { --bg:#0b0f14; --fg:#e6edf3; --muted:#9fb1c1; --accent:#4da3ff; --bad:#ff6b6b; --good:#42d392; --card:#121821; }
  * { box-sizing: border-box; }
  body { margin:0; background:var(--bg); color:var(--fg); font:14px/1.45 system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial; overflow-x:hidden; }
  header { padding:16px 20px; border-bottom:1px solid #18222f; display:flex; gap:16px; align-items:center; flex-wrap:wrap; }
  header h1 { margin:0; font-size:16px; letter-spacing:.5px; color:#cfe6ff; }
  .wrap { display:grid; grid-template-columns: 1fr; gap:16px; padding:16px; max-width:100vw; }
  @media (min-width: 1024px) {
    .wrap { grid-template-columns: 420px 1fr; }
  }
  .card { background:var(--card); border:1px solid #18222f; border-radius:12px; padding:12px; max-width:100%; overflow:hidden; }
  .card h2 { margin:0 0 8px; font-size:13px; color:#cfe6ff; letter-spacing:.4px; }
  textarea, input, select, button { font: inherit; box-sizing:border-box; }
  textarea { width:100%; max-width:100%; height:180px; background:#0e141b; color:var(--fg); border:1px solid #253244; border-radius:10px; padding:10px; box-sizing:border-box; }
  .row { display:flex; gap:8px; align-items:center; margin:6px 0; flex-wrap:wrap; }
  .row input[type="text"], .row input[type="number"] { min-width:0; flex:1 1 auto; }
  .row label { color:var(--muted); font-size:12px; }
  .chips { display:flex; gap:6px; flex-wrap:wrap; }
  .chip { background:#0e141b; border:1px dashed #31455e; padding:6px 8px; border-radius:999px; }
  .pill { padding:4px 8px; border-radius:999px; font-size:12px; border:1px solid #253244; color:#d8e6f6; background:#0e141b; min-width:0; max-width:100%; }
  button.primary { background:var(--accent); color:#001122; border:none; padding:10px 14px; border-radius:10px; font-weight:600; cursor:pointer; white-space:nowrap; }
  button.ghost { background:#0e141b; color:var(--fg); border:1px solid #253244; padding:8px 10px; border-radius:10px; cursor:pointer; white-space:nowrap; }
  table { width:100%; border-collapse:collapse; white-space:nowrap; }
  .table-scroll { overflow-x:auto; max-width:100%; }
  th, td { border-bottom:1px solid #223146; padding:6px 8px; text-align:left; }
  th { color:#cfe6ff; font-weight:600; font-size:12px; }
  .muted { color:var(--muted); }
  .warn { color:var(--bad); }
  .ok { color:var(--good); }
  .tiny { font-size:12px; }
  .grid { display:grid; grid-template-columns: 1fr; gap:12px; }
  @media (min-width: 768px) {
    .grid { grid-template-columns: repeat(auto-fit, minmax(260px, 1fr)); }
  }
  .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; word-break:break-all; }
  pre { overflow-x:auto; max-width:100%; }
  .hint { color:#9fb1c1; font-size:12px; word-break:break-word; }
  .footer { padding:10px 16px; border-top:1px solid #18222f; color:#7ea2c7; font-size:11px; }
  @media (max-width: 640px) {
    header h1 { font-size:14px; }
    .hint { font-size:11px; }
    textarea { height:120px; font-size:13px; }
    button.primary, button.ghost { padding:8px 12px; font-size:13px; }
  }
  .question-interface { margin-top:16px; }
  .question-type { display:flex; gap:12px; margin-bottom:12px; flex-wrap:wrap; }
  .question-type button { flex:1; min-width:140px; }
  .question-form { display:none; }
  .question-form.active { display:block; }
  .answer-box { margin-top:12px; padding:12px; border-radius:8px; background:#0e141b; border:1px solid #253244; }
  .answer-shared { color:#42d392; font-weight:600; margin-bottom:8px; }
  .answer-private { color:#9fb1c1; font-size:12px; margin-top:8px; }
  .answer-private.hidden { filter: blur(8px); user-select: none; }
  .private-toggle { font-size:11px; padding:6px 12px; cursor:pointer; margin-top:8px; display:inline-block; }
  select.pill { padding:6px 10px; }
</style>
</head>
<body>
<header>
  <h1>Scenario Handler ‚Äî Offline SAT</h1>
  <span class="hint">Paste Mermaid-like graph, set constraints, then Generate.</span>
</header>

<div class="wrap">
  <section class="card">
    <h2>Map (Mermaid-like)</h2>
    <div class="hint tiny">Use undirected edges with <span class="mono">---</span>. Node IDs are room names (quote names with spaces).</div>
    <textarea id="mermaidInput">graph TD
  Foyer --- Stairs
  Foyer --- Gallery
  Gallery --- Stairs
  Gallery --- Masks
  Masks --- DanceRoom
  Masks --- MusicRoom
  MusicRoom --- DanceRoom</textarea>
    <div class="row">
      <label for="chars">Characters:</label>
      <input id="chars" class="pill" value="A, B, C, D, S, J" />
      <label for="steps">Timesteps (T):</label>
      <input id="steps" type="number" min="2" max="10" class="pill" value="6" />
    </div>
    <div class="row">
      <label>Movement:</label>
      <label><input type="checkbox" id="mustMove" checked /> Must move each time</label>
      <label><input type="checkbox" id="allowStay" /> Allow stay (overrides ‚Äúmust move‚Äù)</label>
    </div>
    <div class="row">
      <label for="seed">Seed:</label>
      <input id="seed" class="pill" value="0" />
      <button class="ghost" id="validateBtn">Validate Map</button>
    </div>

    <h2>Scenarios (Select One)</h2>
    <div class="row">
      <label><input type="radio" name="scenario" id="s1" value="s1" /> S1: Poison (assassin alone with victim, first char is assassin)</label>
    </div>
    <div class="row tiny">
      <label>Poison room (optional exact):</label>
      <input id="s1_room" class="pill" placeholder="e.g., Office" />
      <label>Poison time (1..T):</label>
      <input id="s1_time" class="pill" placeholder="e.g., 3" />
      <span class="muted tiny">(Assassin is always first character in list)</span>
    </div>
    <div class="row">
      <label><input type="radio" name="scenario" id="s2" value="s2" /> S2: Phantom (one character is alone at every time)</label>
    </div>
    <div class="row">
      <label><input type="radio" name="scenario" id="s3" value="s3" /> S3: Singer's Jewels (someone must enter the first listed room)</label>
    </div>
    <div class="row">
      <label><input type="radio" name="scenario" id="s4" value="s4" /> S4: Bomb duo (two culprits are the <i>only pair ever alone together</i> and they must share a private meeting)</label>
    </div>
    <div class="row">
      <label><input type="radio" name="scenario" id="s5" value="s5" /> S5: Lovers (two lovers never meet; every pair of non-lovers must meet at least once)</label>
    </div>
    <div class="row">
      <label><input type="radio" name="scenario" id="s6" value="s6" /> S6: Phantom + Lovers (one phantom alone at every time, two separate lovers who never meet)</label>
    </div>
    <div class="row">
      <label><input type="radio" name="scenario" id="s7" value="s7" /> S7: Aggrosassin (serial poisoner who kills everyone they meet 1-on-1)</label>
    </div>
    <div class="row">
      <label><input type="radio" name="scenario" id="s8" value="s8" /> S8: The Freeze (identify Mr. Freeze and the frozen victims)</label>
    </div>

    <div class="row">
      <label>Difficulty percentile (0-100):</label>
      <input id="percentile" type="number" min="0" max="100" step="0.1" class="pill" value="50" />
      <label>Samples:</label>
      <input id="samples" type="number" min="10" max="5000" class="pill" value="10" />
    </div>
    <div class="row">
      <button class="primary" id="genBtn">Generate</button>
      <span id="status" class="hint"></span>
    </div>
  </section>

  <section class="card">
    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
      <h2 style="margin:0;">Results</h2>
      <button class="ghost" id="toggleResultsBtn" style="display:none;">‚ñº Collapse</button>
    </div>
    <div id="resultsHint" class="hint tiny">No results yet.</div>
    <div id="results" style="display:none">
      <div class="grid">
        <div class="card">
          <h2>Schedule (Characters √ó Time)</h2>
          <div id="schedule"></div>
        </div>
        <div class="card">
          <h2>Counts by Time</h2>
          <div id="byTime"></div>
        </div>
        <div class="card">
          <h2>Visits</h2>
          <div id="visits"></div>
        </div>
        <div class="card">
          <h2>Private Facts</h2>
          <div id="privateFacts"></div>
        </div>
        <div class="card">
          <h2>Generation Statistics</h2>
          <div id="genStats" class="tiny"></div>
        </div>
        <div class="card">
          <h2>Scenario String</h2>
          <div class="hint tiny">This string encodes the entire scenario. Share it or bookmark the URL to recreate this exact scenario.</div>
          <textarea id="scenarioString" class="mono tiny" readonly style="height:80px; font-size:11px; resize:vertical;"></textarea>
          <div class="row" style="margin-top:8px;">
            <button class="ghost" id="copyScenarioBtn">üìã Copy String</button>
            <button class="ghost" id="copyURLBtn">üîó Copy URL</button>
          </div>
        </div>
        <div class="card">
          <h2>Raw JSON</h2>
          <pre class="mono tiny" id="rawJson"></pre>
          <button class="ghost" id="downloadBtn">Download JSON</button>
        </div>
      </div>
    </div>
  </section>

  <section class="card">
    <h2>Starting Information</h2>
    <div class="starting-info-interface">
      <div class="row">
        <label>Timestep:</label>
        <select id="startingTime" class="pill"></select>
        <label>Number of characters:</label>
        <input id="startingCharCount" type="number" min="1" max="10" class="pill" value="3" style="width:80px;" />
        <button class="primary" id="showStartingInfoBtn">Show Starting Positions</button>
      </div>
      <div id="startingInfoAnswer" class="answer-box" style="display:none;">
        <div class="answer-shared" id="startingInfoShared"></div>
      </div>
    </div>
  </section>

  <section class="card">
    <h2>Question Interface</h2>
    <div class="question-interface">
      <div class="question-type">
        <button class="ghost" id="askLocTimeBtn">Location + Time</button>
        <button class="ghost" id="askLocCharBtn">Location + Character</button>
      </div>
      
      <div id="locTimeForm" class="question-form">
        <div class="row">
          <label>Location:</label>
          <select id="locTimeLocation" class="pill"></select>
          <label>Time:</label>
          <select id="locTimeTime" class="pill"></select>
          <button class="primary" id="askLocTimeSubmit">Ask</button>
        </div>
        <div id="locTimeAnswer" class="answer-box" style="display:none;">
          <div class="answer-shared" id="locTimeShared"></div>
          <div>
            <button class="ghost private-toggle" id="locTimeToggle">üëÅÔ∏è Show</button>
          </div>
          <div class="answer-private hidden" id="locTimePrivate"></div>
        </div>
      </div>
      
      <div id="locCharForm" class="question-form">
        <div class="row">
          <label>Location:</label>
          <select id="locCharLocation" class="pill"></select>
          <label>Character:</label>
          <select id="locCharChar" class="pill"></select>
          <button class="primary" id="askLocCharSubmit">Ask</button>
        </div>
        <div id="locCharAnswer" class="answer-box" style="display:none;">
          <div class="answer-shared" id="locCharShared"></div>
          <div>
            <button class="ghost private-toggle" id="locCharToggle">üëÅÔ∏è Show</button>
          </div>
          <div class="answer-private hidden" id="locCharPrivate"></div>
        </div>
      </div>
    </div>
  </section>
</div>

<div class="footer tiny">SAT core: DPLL + unit propagation (pure JS). Scenarios: S1 (Poison), S2 (Phantom + non-isolation), S3 (Singer's Jewels), S4 (Bomb Duo ‚Äì only pair allowed alone, and it happens at least once), S5 (Lovers + all non-lovers meet), S6 (Phantom + Lovers), S7 (Aggrosassin - serial poisoner), S8 (The Freeze - victims frozen in place).</div>

<script type="module">
/* ===========================
   Import from scenario-solver.js
   =========================== */
import {
  parseMermaid,
  neighbors,
  buildCNF,
  solveAndDecode
} from './src/scenario-solver.js';

/* ===========================
   Scoring Functions (HTML-specific)
   =========================== */
function scoreScenario(res, cfg) {
  let score = 0;
  const scores = {};
  
  // S2: Phantom scoring
  if (cfg.scenarios.s2 && res.priv.phantom) {
    scores.phantom = scorePhantom(res, cfg);
    score += scores.phantom;
  }
  
  // S5/S6: Lovers scoring
  if (cfg.scenarios.s5 && res.priv.lovers) {
    scores.lovers = scoreLovers(res, cfg);
    score += scores.lovers;
  }
  
  // S1: Poison scoring
  if (cfg.scenarios.s1 && res.priv.assassin) {
    scores.poison = scorePoison(res, cfg);
    score += scores.poison;
  }
  
  // S4: Bomb duo scoring
  if (cfg.scenarios.s4 && res.priv.bomb_duo) {
    scores.bomb = scoreBomb(res, cfg);
    score += scores.bomb;
  }

  // S3: Singer's Jewels scoring
  if (cfg.scenarios.s3) {
    scores.jewels = scoreJewels(res, cfg);
    score += scores.jewels;
  }

  // S7: Aggrosassin scoring
  if (cfg.scenarios.s7 && res.priv.aggrosassin) {
    scores.aggrosassin = scoreAggrosassin(res, cfg);
    score += scores.aggrosassin;
  }

  // S8: Freeze scoring
  if (cfg.scenarios.s8 && res.priv.freeze) {
    scores.freeze = scoreFreeze(res, cfg);
    score += scores.freeze;
  }

  return { total: score, breakdown: scores };
}

function scorePhantom(res, cfg) {
  // Higher score = harder puzzle
  // Measure: How many other characters are "almost phantom" (alone many times but not all)
  const phantom = res.priv.phantom;
  const T = cfg.T;
  const chars = cfg.chars;
  
  let score = 0;
  
  for (const char of chars) {
    if (char === phantom) continue;
    
    // Count how many times this character is alone
    let aloneCount = 0;
    for (let t = 0; t < T; t++) {
      const room = res.schedule[char][t];
      const othersInRoom = chars.filter(c => 
        c !== char && res.schedule[c][t] === room
      ).length;
      if (othersInRoom === 0) aloneCount++;
    }
    
    // Characters alone T-1 or T-2 times are "red herrings" - increase difficulty
    if (aloneCount >= T - 2) {
      score += 100 * (aloneCount / T); // Weight by proportion
    } else if (aloneCount >= T / 2) {
      score += 50 * (aloneCount / T); // Moderate red herrings
    }
  }
  
  return score;
}

function scoreLovers(res, cfg) {
  // Higher score = harder puzzle
  // Measure: How many other character pairs are "almost lovers" (rarely meet)
  const [lover1, lover2] = res.priv.lovers;
  const T = cfg.T;
  const chars = cfg.chars;
  
  let score = 0;
  
  // Check all other pairs
  for (let i = 0; i < chars.length; i++) {
    for (let j = i + 1; j < chars.length; j++) {
      const c1 = chars[i], c2 = chars[j];
      if ((c1 === lover1 && c2 === lover2) || (c1 === lover2 && c2 === lover1)) continue;
      
      // Count meetings
      let meetings = 0;
      for (let t = 0; t < T; t++) {
        if (res.schedule[c1][t] === res.schedule[c2][t]) meetings++;
      }
      
      // Pairs that meet 0-1 times are red herrings
      if (meetings === 0) score += 100;
      else if (meetings === 1) score += 80;
      else if (meetings <= 2) score += 40;
    }
  }
  
  return score;
}

function scorePoison(res, cfg) {
  // Higher score = harder puzzle
  // Measure: How many other pairs of characters are alone together at various times
  const assassin = res.priv.assassin;
  const victim = res.priv.victim;
  const poisonTime = res.priv.poison_time - 1; // 0-indexed
  const poisonRoom = res.priv.poison_room;
  const T = cfg.T;
  const chars = cfg.chars;
  
  let score = 0;
  
  // Count other pairs who are alone together (red herrings)
  for (let i = 0; i < chars.length; i++) {
    for (let j = i + 1; j < chars.length; j++) {
      const c1 = chars[i], c2 = chars[j];
      
      // Skip the actual assassin-victim pair at poison time
      if ((c1 === assassin && c2 === victim) || (c1 === victim && c2 === assassin)) {
        continue;
      }
      
      // Check if they're alone together at any time
      for (let t = 0; t < T; t++) {
        const room1 = res.schedule[c1][t];
        const room2 = res.schedule[c2][t];
        
        if (room1 === room2) {
          const othersInRoom = chars.filter(c => 
            c !== c1 && c !== c2 && res.schedule[c][t] === room1
          ).length;
          
          if (othersInRoom === 0) {
            // This pair is alone together - red herring
            score += 60;
          }
        }
      }
    }
  }
  
  return score;
}

function scoreJewels(res, cfg) {
  // Complexity rises when many moments feature exactly two occupants,
  // creating extra hand-off opportunities in the narrative.
  const T = cfg.T;
  const rooms = cfg.rooms;
  const chars = cfg.chars;
  let score = 0;

  const jewelRoom = rooms[0];

  for (let t = 0; t < T; t++) {
    for (const room of rooms) {
      let count = 0;
      for (const char of chars) {
        if (res.schedule[char][t] === room) count++;
      }
      if (count === 2) {
        score += room === jewelRoom ? 80 : 40;
      }
    }
  }

  return score;
}
function scoreBomb(res, cfg) {
  // Higher score = harder puzzle
  // Measure: How often bombers are with other people (camouflage)
  // and how many "near miss" groups of 3 exist
  const [bomber1, bomber2] = res.priv.bomb_duo;
  const T = cfg.T;
  const chars = cfg.chars;

  let score = 0;

  // Count times when bombers are together WITH other people (not alone)
  for (let t = 0; t < T; t++) {
    const room1 = res.schedule[bomber1][t];
    const room2 = res.schedule[bomber2][t];

    if (room1 === room2) {
      const othersInRoom = chars.filter(c =>
        c !== bomber1 && c !== bomber2 && res.schedule[c][t] === room1
      ).length;

      if (othersInRoom > 0) {
        // Bombers together but not alone - camouflage
        score += 40;
      }
    }
  }

  // Count "near miss" situations: groups of exactly 3 people
  // These are confusing because they're "almost" a suspicious pair
  for (let t = 0; t < T; t++) {
    for (const room of cfg.rooms) {
      const charsInRoom = chars.filter(c => res.schedule[c][t] === room);
      if (charsInRoom.length === 3) {
        score += 30; // Near-miss group
      }
    }
  }

  return score;
}

function scoreAggrosassin(res, cfg) {
  // Higher score = harder puzzle
  // Measure: More victims and more pair meetings in general
  const T = cfg.T;
  const chars = cfg.chars;
  
  let score = 0;
  
  // +10 points per victim (increased from 3 to weight kills more)
  const victimCount = res.priv.victims ? res.priv.victims.length : 0;
  score += victimCount * 10;
  
  // +1 point per instance of exactly 2 people in a room
  for (let t = 0; t < T; t++) {
    for (const room of cfg.rooms) {
      const charsInRoom = chars.filter(c => res.schedule[c][t] === room);
      if (charsInRoom.length === 2) {
        score += 1;
      }
    }
  }

  return score;
}

function scoreFreeze(res, cfg) {
  // Higher score = harder puzzle
  // Measure: More freeze victims and red herring 1:1 meetings
  const freeze = res.priv.freeze;
  if (!freeze) return 0;

  const kills = res.priv.freeze_kills || [];
  const T = cfg.T;
  const chars = cfg.chars;

  let score = kills.length * 100;

  let redHerrings = 0;
  for (let t = 0; t < T; t++) {
    for (const room of cfg.rooms) {
      const charsInRoom = chars.filter(c => res.schedule[c][t] === room);
      if (charsInRoom.length === 2 && !charsInRoom.includes(freeze)) {
        redHerrings++;
      }
    }
  }

  score += redHerrings * 5;
  return score;
}

/* ===========================
   URL State Management (HTML-specific)
   =========================== */
function encodeScenarioToURL(res, cfg) {
  // Create a compact representation of the scenario
  const state = {
    v: 1, // version
    r: cfg.rooms,
    c: cfg.chars,
    t: cfg.T,
    e: cfg.edges,
    s: cfg.seed,
    // Encode schedule as compact string: char_index,room_index for each timestep
    // Format: "0,1,2,0,1,2|1,2,0,1,2,0|..." (pipe separates characters)
    sch: cfg.chars.map(char => {
      return res.schedule[char].map(room => cfg.rooms.indexOf(room)).join(',');
    }).join('|')
  };
  
  // Convert to base64 JSON
  const json = JSON.stringify(state);
  const encoded = btoa(encodeURIComponent(json));
  return encoded;
}

function decodeScenarioFromURL(encoded) {
  try {
    const json = decodeURIComponent(atob(encoded));
    const state = JSON.parse(json);
    
    if (state.v !== 1) return null; // Version mismatch
    
    // Reconstruct schedule
    const schedule = {};
    const schedParts = state.sch.split('|');
    state.c.forEach((char, ci) => {
      const roomIndices = schedParts[ci].split(',').map(Number);
      schedule[char] = roomIndices.map(ri => state.r[ri]);
    });
    
    // Reconstruct byTime
    const byTime = {};
    for (let t = 0; t < state.t; t++) {
      const counts = {};
      state.r.forEach(r => counts[r] = 0);
      state.c.forEach(char => {
        const room = schedule[char][t];
        if (counts[room] != null) counts[room]++;
      });
      byTime[t + 1] = counts;
    }
    
    // Reconstruct visits
    const visits = {};
    state.c.forEach(char => {
      const v = {};
      state.r.forEach(r => v[r] = 0);
      for (let t = 0; t < state.t; t++) {
        v[schedule[char][t]]++;
      }
      visits[char] = v;
    });
    
    return {
      schedule,
      byTime,
      visits,
      rooms: state.r,
      chars: state.c,
      T: state.t,
      edges: state.e,
      seed: state.s
    };
  } catch (e) {
    console.error('Failed to decode scenario from URL:', e);
    return null;
  }
}

function updateURL(encoded) {
  const url = new URL(window.location);
  url.searchParams.set('scenario', encoded);
  window.history.pushState({}, '', url);
}

function getScenarioFromURL() {
  const params = new URLSearchParams(window.location.search);
  return params.get('scenario');
}

/* ===========================
   UI glue
   =========================== */
function qs(id){ return document.getElementById(id); }
function renderTable(container, obj, headerLeft){
  const el = typeof container==="string"? qs(container) : container;
  let html = "<div class='table-scroll'><table><thead><tr>";
  if (headerLeft) html += `<th>${headerLeft}</th>`;
  const keys = Object.keys(obj);
  const isArrayRows = Array.isArray(obj[keys[0]]);
  const cols = isArrayRows ? obj[keys[0]].length : Object.keys(obj[keys[0]] || {}).length;
  if (isArrayRows){
    for (let i=0;i<cols;i++) html += `<th>t=${i+1}</th>`;
    html += "</tr></thead><tbody>";
    for (const rowKey of keys){
      html += `<tr><th>${rowKey}</th>`;
      for (const val of obj[rowKey]) html += `<td>${val}</td>`;
      html += `</tr>`;
    }
  } else {
    const subkeys = Object.keys(obj[keys[0]]||{});
    for (const sk of subkeys) html += `<th>${sk}</th>`;
    html += "</tr></thead><tbody>";
    for (const rowKey of keys){
      html += `<tr><th>${rowKey}</th>`;
      for (const sk of subkeys) html += `<td>${obj[rowKey][sk]}</td>`;
      html += `</tr>`;
    }
  }
  html += "</tbody></table></div>";
  el.innerHTML = html;
}

qs("validateBtn").addEventListener("click", ()=>{
  const {rooms, edges} = parseMermaid(qs("mermaidInput").value);
  const msg = (rooms.length>=2 && edges.length>=1)
    ? `<span class="ok">OK:</span> ${rooms.length} rooms, ${edges.length} doors`
    : `<span class="warn">Need ‚â•2 rooms and ‚â•1 door.</span>`;
  qs("status").innerHTML = msg;
});

qs("genBtn").addEventListener("click", async ()=>{
  const percentile = Number(qs("percentile").value);
  const sampleCount = Number(qs("samples").value) || 100;
  
  qs("status").textContent = `Generating ${sampleCount} scenarios‚Ä¶`;
  
  const {rooms, edges} = parseMermaid(qs("mermaidInput").value);
  const chars = qs("chars").value.split(",").map(s=>s.trim()).filter(Boolean);
  const T = Math.max(2, Math.min(10, Number(qs("steps").value)||6));
  const mustMove = qs("mustMove").checked;
  const allowStay = qs("allowStay").checked;

  if (rooms.length<2 || edges.length<1){ qs("status").innerHTML = `<span class="warn">Map too small.</span>`; return; }
  if (chars.length<2){ qs("status").innerHTML = `<span class="warn">Add at least 2 characters.</span>`; return; }

  // Get selected scenario (radio button)
  const selectedScenario = document.querySelector('input[name="scenario"]:checked');
  const scenarioValue = selectedScenario ? selectedScenario.value : null;
  
  if (!scenarioValue) {
    qs("status").innerHTML = `<span class="warn">Please select a scenario.</span>`;
    return;
  }

  const cfg = {
    rooms, edges, chars, T, mustMove, allowStay,
    scenarios: {
      s1: scenarioValue === 's1',
      s2: scenarioValue === 's2' || scenarioValue === 's6',
      s3: scenarioValue === 's3',
      s4: scenarioValue === 's4',
      s5: scenarioValue === 's5' || scenarioValue === 's6',
      s7: scenarioValue === 's7',
      s8: scenarioValue === 's8',
      s1_room: qs("s1_room").value.trim() || null,
      s1_time: qs("s1_time").value.trim() || null
    }
  };

  try{
    // Multi-generation with scoring
    const solutions = [];
    let skipped = 0;
    const seedInput = qs("seed").value.trim();
    const baseSeed = seedInput === "" ? Math.floor(Math.random() * 10000000) + 1 : Number(seedInput) || 0;
    
    for (let i = 0; i < sampleCount; i++) {
      cfg.seed = baseSeed + i;
      try {
        const res = solveAndDecode(cfg);
        if (res) {
          const scored = { ...res, score: scoreScenario(res, cfg) };
          solutions.push(scored);
        } else {
          skipped++;
        }
      } catch (e) {
        // Skip timeouts or other errors
        skipped++;
        console.warn(`Sample ${i} failed:`, e.message);
      }
      
      if (i % 10 === 0) {
        qs("status").textContent = `Generated ${i}/${sampleCount} (${solutions.length} valid, ${skipped} skipped)...`;
        await new Promise(r => setTimeout(r, 0)); // Allow UI update
      }
    }
    
    if (solutions.length === 0) {
      qs("status").innerHTML = `<span class="warn">No solutions found (${skipped} samples timed out or failed).</span>`;
      return;
    }
    
    // Sort by score (ascending - lower scores are easier)
    solutions.sort((a, b) => a.score.total - b.score.total);
    
    // Select solution at the specified percentile
    const targetIdx = Math.floor((percentile / 100) * (solutions.length - 1));
    const res = solutions[targetIdx];
    
    // Encode scenario to URL
    const encoded = encodeScenarioToURL(res, cfg);
    updateURL(encoded);
    
    qs("status").innerHTML = `<span class="ok">Selected ${percentile}th percentile scenario</span> (score: ${res.score.total.toFixed(1)}, rank ${targetIdx+1}/${solutions.length}, ${skipped} skipped)`;
    // Display selected solution
    qs("resultsHint").style.display = "none";
    qs("results").style.display = "block";
    qs("toggleResultsBtn").style.display = "inline-block";
    renderTable("schedule", res.schedule, "Character");
    renderTable("byTime", res.byTime, "Time");
    renderTable("visits", res.visits, "Character");

    // Private facts
    const pf = [];
    if (res.priv.phantom) pf.push(`<div>Phantom: <b>${res.priv.phantom}</b></div>`);
    if (res.priv.lovers) pf.push(`<div>Lovers: <b>${res.priv.lovers[0]}</b> + <b>${res.priv.lovers[1]}</b></div>`);
    if (res.priv.assassin) pf.push(`<div>Assassin: <b>${res.priv.assassin}</b> poisoned <b>${res.priv.victim}</b> @ t=${res.priv.poison_time}, room=${res.priv.poison_room}</div>`);
    if (res.priv.bomb_duo) pf.push(`<div>Bomb duo: <b>${res.priv.bomb_duo[0]}</b> + <b>${res.priv.bomb_duo[1]}</b></div>`);
    if (res.priv.aggrosassin) pf.push(`<div>Aggrosassin: <b>${res.priv.aggrosassin}</b> killed <b>${res.priv.victims.length}</b> victim${res.priv.victims.length === 1 ? '' : 's'}: ${res.priv.victims.join(', ')}</div>`);
    if (res.priv.freeze) {
      const victims = res.priv.freeze_victims || [];
      const kills = res.priv.freeze_kills || [];
      let detail = '';
      if (victims.length) {
        const killSummary = kills.map(k => `${k.victim} @ t=${k.time}, ${k.room}`).join('; ');
        detail = ` froze <b>${victims.length}</b> victim${victims.length === 1 ? '' : 's'}: ${victims.join(', ')}`;
        if (killSummary) {
          detail += ` (first freezes: ${killSummary})`;
        }
      }
      pf.push(`<div>Mr. Freeze: <b>${res.priv.freeze}</b>${detail}</div>`);
    }
    if (pf.length===0) pf.push(`<div class="muted">None</div>`);
    qs("privateFacts").innerHTML = pf.join("");

    // Display generation statistics
    const stats = res.stats || {};
    const avgSolveTime = solutions.reduce((sum, s) => sum + (s.stats?.solveTimeMs || 0), 0) / solutions.length;
    const statsHtml = `
      <div style="display: grid; grid-template-columns: auto 1fr; gap: 4px 12px;">
        <span class="muted">SAT Variables:</span>
        <span><b>${stats.totalVars}</b></span>

        <span class="muted">SAT Clauses:</span>
        <span><b>${stats.totalClauses}</b></span>

        <span class="muted">Avg Clause Length:</span>
        <span><b>${stats.avgClauseLength?.toFixed(2)}</b> literals</span>

        <span class="muted">Solve Time (this):</span>
        <span><b>${stats.solveTimeMs}</b>ms</span>

        <span class="muted">Avg Solve Time:</span>
        <span><b>${avgSolveTime.toFixed(1)}</b>ms</span>

        <span class="muted">Valid Solutions:</span>
        <span><b>${solutions.length}</b> / ${sampleCount} (${((solutions.length/sampleCount)*100).toFixed(1)}%)</span>

        <span class="muted">Difficulty Score:</span>
        <span><b>${res.score.total.toFixed(1)}</b> (${percentile}th percentile)</span>

        <span class="muted">Score Breakdown:</span>
        <span>${Object.entries(res.score.breakdown).map(([k,v]) => `${k}: ${v.toFixed(0)}`).join(', ') || 'N/A'}</span>
      </div>
    `;
    qs("genStats").innerHTML = statsHtml;

    // Display scenario string
    qs("scenarioString").value = encoded;
    
    // Copy buttons
    qs("copyScenarioBtn").onclick = ()=>{
      navigator.clipboard.writeText(encoded).then(()=>{
        const btn = qs("copyScenarioBtn");
        const orig = btn.textContent;
        btn.textContent = "‚úì Copied!";
        setTimeout(()=> btn.textContent = orig, 2000);
      });
    };
    
    qs("copyURLBtn").onclick = ()=>{
      navigator.clipboard.writeText(window.location.href).then(()=>{
        const btn = qs("copyURLBtn");
        const orig = btn.textContent;
        btn.textContent = "‚úì Copied!";
        setTimeout(()=> btn.textContent = orig, 2000);
      });
    };

    const raw = { schedule: res.schedule, by_time: res.byTime, visits: res.visits, private: res.priv, meta: res.meta };
    qs("rawJson").textContent = JSON.stringify(raw, null, 2);

    qs("downloadBtn").onclick = ()=>{
      const blob = new Blob([JSON.stringify(raw,null,2)], {type:"application/json"});
      const a = document.createElement("a");
      a.href = URL.createObjectURL(blob);
      a.download = "scenario_solution.json";
      a.click();
      URL.revokeObjectURL(a.href);
    };

    // Setup question interface
    setupQuestionInterface(res, cfg);
  }catch(e){
    console.error(e);
    qs("status").innerHTML = `<span class="warn">Error: ${e.message}</span>`;
  }
});

function setupQuestionInterface(res, cfg){
  const rooms = cfg.rooms;
  const chars = cfg.chars;
  const T = cfg.T;

  // Populate dropdowns
  const locTimeLocation = qs("locTimeLocation");
  const locCharLocation = qs("locCharLocation");
  const locCharChar = qs("locCharChar");
  const locTimeTime = qs("locTimeTime");
  const startingTime = qs("startingTime");

  locTimeLocation.innerHTML = rooms.map(r => `<option value="${r}">${r}</option>`).join("");
  locCharLocation.innerHTML = rooms.map(r => `<option value="${r}">${r}</option>`).join("");
  locCharChar.innerHTML = chars.map(c => `<option value="${c}">${c}</option>`).join("");
  locTimeTime.innerHTML = Array.from({length:T}, (_,i) => `<option value="${i+1}">t=${i+1}</option>`).join("");
  startingTime.innerHTML = Array.from({length:T}, (_,i) => `<option value="${i+1}"${i===0?' selected':''}>t=${i+1}</option>`).join("");

  // Toggle between question types
  qs("askLocTimeBtn").onclick = ()=>{
    qs("locTimeForm").classList.add("active");
    qs("locCharForm").classList.remove("active");
    qs("locTimeAnswer").style.display = "none";
  };
  qs("askLocCharBtn").onclick = ()=>{
    qs("locCharForm").classList.add("active");
    qs("locTimeForm").classList.remove("active");
    qs("locCharAnswer").style.display = "none";
  };

  // Location + Time question
  qs("askLocTimeSubmit").onclick = ()=>{
    const location = locTimeLocation.value;
    const time = Number(locTimeTime.value);
    
    // Count how many characters were in this location at this time
    const charsAtLocation = [];
    for (const char of chars){
      if (res.schedule[char][time-1] === location){
        charsAtLocation.push(char);
      }
    }
    
    const count = charsAtLocation.length;
    
    // Deterministically pick one character to reveal (based on location + time hash)
    let revealedChar = "none";
    if (count > 0) {
      // Simple hash: sum char codes of location + time
      let hash = time;
      for (let i = 0; i < location.length; i++) {
        hash = (hash * 31 + location.charCodeAt(i)) & 0x7fffffff;
      }
      const idx = hash % charsAtLocation.length;
      revealedChar = charsAtLocation[idx];
    }
    
    qs("locTimeShared").innerHTML = `üü¢ Shared: <b>${count}</b> character${count===1?'':'s'} ${count===1?'was':'were'} in ${location} at t=${time}`;
    qs("locTimePrivate").innerHTML = `‚ö™ Private: One character present: <b>${revealedChar}</b>`;
    qs("locTimePrivate").classList.add("hidden");
    qs("locTimeToggle").textContent = "üëÅÔ∏è Show";
    qs("locTimeAnswer").style.display = "block";
    
    // Setup toggle handler
    qs("locTimeToggle").onclick = ()=>{
      const privateEl = qs("locTimePrivate");
      const btn = qs("locTimeToggle");
      if (privateEl.classList.contains("hidden")) {
        privateEl.classList.remove("hidden");
        btn.textContent = "üëÅÔ∏è Hide";
      } else {
        privateEl.classList.add("hidden");
        btn.textContent = "üëÅÔ∏è Show";
      }
    };
  };

  // Location + Character question
  qs("askLocCharSubmit").onclick = ()=>{
    const location = locCharLocation.value;
    const character = locCharChar.value;
    
    // Count how many times this character visited this location
    const visitCount = res.visits[character][location] || 0;
    
    // Find which times they visited
    const times = [];
    for (let t=0; t<T; t++){
      if (res.schedule[character][t] === location){
        times.push(t+1);
      }
    }
    
    // Deterministically pick one time to reveal (based on location + character hash)
    let revealedTime = "never";
    if (times.length > 0) {
      // Simple hash: sum char codes of location + character
      let hash = 0;
      for (let i = 0; i < location.length; i++) {
        hash = (hash * 31 + location.charCodeAt(i)) & 0x7fffffff;
      }
      for (let i = 0; i < character.length; i++) {
        hash = (hash * 31 + character.charCodeAt(i)) & 0x7fffffff;
      }
      const idx = hash % times.length;
      revealedTime = `t=${times[idx]}`;
    }
    
    qs("locCharShared").innerHTML = `üü¢ Shared: <b>${visitCount}</b> visit${visitCount===1?'':'s'} by ${character} to ${location}`;
    qs("locCharPrivate").innerHTML = `‚ö™ Private: One time visited: <b>${revealedTime}</b>`;
    qs("locCharPrivate").classList.add("hidden");
    qs("locCharToggle").textContent = "üëÅÔ∏è Show";
    qs("locCharAnswer").style.display = "block";
    
    // Setup toggle handler
    qs("locCharToggle").onclick = ()=>{
      const privateEl = qs("locCharPrivate");
      const btn = qs("locCharToggle");
      if (privateEl.classList.contains("hidden")) {
        privateEl.classList.remove("hidden");
        btn.textContent = "üëÅÔ∏è Hide";
      } else {
        privateEl.classList.add("hidden");
        btn.textContent = "üëÅÔ∏è Show";
      }
    };
  };

  // Starting Information handler
  qs("showStartingInfoBtn").onclick = ()=>{
    const time = Number(startingTime.value);
    const charCount = Math.min(chars.length, Math.max(1, Number(qs("startingCharCount").value) || 3));
    
    // Deterministically select characters based on time (for consistency)
    // Use a simple hash to pick characters
    let hash = time * 7919; // Prime number for better distribution
    const selectedChars = [];
    const availableChars = [...chars];
    
    for (let i = 0; i < charCount && availableChars.length > 0; i++) {
      hash = (hash * 31 + i) & 0x7fffffff;
      const idx = hash % availableChars.length;
      selectedChars.push(availableChars[idx]);
      availableChars.splice(idx, 1);
    }
    
    // Get locations for selected characters at the specified time
    const locations = selectedChars.map(char => {
      const location = res.schedule[char][time-1];
      return `<b>${char}</b>: ${location}`;
    });
    
    qs("startingInfoShared").innerHTML = `üü¢ At t=${time}, the following character locations are revealed:<br/><br/>` + locations.join('<br/>');
    qs("startingInfoAnswer").style.display = "block";
  };

  // Default to Location + Time
  qs("askLocTimeBtn").click();
}

// Toggle results collapse/expand
qs("toggleResultsBtn").addEventListener("click", ()=>{
  const resultsDiv = qs("results");
  const btn = qs("toggleResultsBtn");
  if (resultsDiv.style.display === "none") {
    resultsDiv.style.display = "block";
    btn.textContent = "‚ñº Collapse";
  } else {
    resultsDiv.style.display = "none";
    btn.textContent = "‚ñ∂ Expand";
  }
});

// Load scenario from URL on page load
window.addEventListener('DOMContentLoaded', ()=>{
  const encoded = getScenarioFromURL();
  if (encoded) {
    const decoded = decodeScenarioFromURL(encoded);
    if (decoded) {
      // Populate form fields
      const mermaidLines = ['graph TD'];
      decoded.edges.forEach(([a, b]) => {
        const aQuoted = a.includes(' ') ? `"${a}"` : a;
        const bQuoted = b.includes(' ') ? `"${b}"` : b;
        mermaidLines.push(`  ${aQuoted} --- ${bQuoted}`);
      });
      qs("mermaidInput").value = mermaidLines.join('\n');
      qs("chars").value = decoded.chars.join(', ');
      qs("steps").value = decoded.T;
      qs("seed").value = decoded.seed;
      
      // Display the scenario
      qs("status").innerHTML = `<span class="ok">Loaded scenario from URL</span>`;
      qs("resultsHint").style.display = "none";
      qs("results").style.display = "block";
      qs("toggleResultsBtn").style.display = "inline-block";
      
      renderTable("schedule", decoded.schedule, "Character");
      renderTable("byTime", decoded.byTime, "Time");
      renderTable("visits", decoded.visits, "Character");
      
      // Note: We don't have private facts in the URL encoding (by design - they're secret!)
      qs("privateFacts").innerHTML = `<div class="muted">Private facts not included in URL (generate to see them)</div>`;
      
      // Display scenario string
      qs("scenarioString").value = encoded;
      
      // Copy buttons
      qs("copyScenarioBtn").onclick = ()=>{
        navigator.clipboard.writeText(encoded).then(()=>{
          const btn = qs("copyScenarioBtn");
          const orig = btn.textContent;
          btn.textContent = "‚úì Copied!";
          setTimeout(()=> btn.textContent = orig, 2000);
        });
      };
      
      qs("copyURLBtn").onclick = ()=>{
        navigator.clipboard.writeText(window.location.href).then(()=>{
          const btn = qs("copyURLBtn");
          const orig = btn.textContent;
          btn.textContent = "‚úì Copied!";
          setTimeout(()=> btn.textContent = orig, 2000);
        });
      };
      
      const raw = { schedule: decoded.schedule, by_time: decoded.byTime, visits: decoded.visits, meta: { source: 'url' } };
      qs("rawJson").textContent = JSON.stringify(raw, null, 2);
      
      qs("downloadBtn").onclick = ()=>{
        const blob = new Blob([JSON.stringify(raw,null,2)], {type:"application/json"});
        const a = document.createElement("a");
        a.href = URL.createObjectURL(blob);
        a.download = "scenario_solution.json";
        a.click();
        URL.revokeObjectURL(a.href);
      };
      
      // Setup question interface with the decoded scenario
      const cfg = {
        rooms: decoded.rooms,
        chars: decoded.chars,
        T: decoded.T,
        edges: decoded.edges
      };
      setupQuestionInterface(decoded, cfg);
    } else {
      qs("status").innerHTML = `<span class="warn">Failed to load scenario from URL</span>`;
    }
  }
});
</script>
</body>
</html>
