<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Scenario Handler (Offline SAT)</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root { --bg:#0b0f14; --fg:#e6edf3; --muted:#9fb1c1; --accent:#4da3ff; --bad:#ff6b6b; --good:#42d392; --card:#121821; }
  * { box-sizing: border-box; }
  body { margin:0; background:var(--bg); color:var(--fg); font:14px/1.45 system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial; overflow-x:hidden; }
  header { padding:16px 20px; border-bottom:1px solid #18222f; display:flex; gap:16px; align-items:center; flex-wrap:wrap; }
  header h1 { margin:0; font-size:16px; letter-spacing:.5px; color:#cfe6ff; }
  .wrap { display:grid; grid-template-columns: 1fr; gap:16px; padding:16px; max-width:100vw; }
  @media (min-width: 1024px) {
    .wrap { grid-template-columns: 420px 1fr; }
  }
  .card { background:var(--card); border:1px solid #18222f; border-radius:12px; padding:12px; max-width:100%; overflow:hidden; }
  .card h2 { margin:0 0 8px; font-size:13px; color:#cfe6ff; letter-spacing:.4px; }
  textarea, input, select, button { font: inherit; box-sizing:border-box; }
  textarea { width:100%; max-width:100%; height:180px; background:#0e141b; color:var(--fg); border:1px solid #253244; border-radius:10px; padding:10px; box-sizing:border-box; }
  .row { display:flex; gap:8px; align-items:center; margin:6px 0; flex-wrap:wrap; }
  .row input[type="text"], .row input[type="number"] { min-width:0; flex:1 1 auto; }
  .row label { color:var(--muted); font-size:12px; }
  .chips { display:flex; gap:6px; flex-wrap:wrap; }
  .chip { background:#0e141b; border:1px dashed #31455e; padding:6px 8px; border-radius:999px; }
  .pill { padding:4px 8px; border-radius:999px; font-size:12px; border:1px solid #253244; color:#d8e6f6; background:#0e141b; min-width:0; max-width:100%; }
  button.primary { background:var(--accent); color:#001122; border:none; padding:10px 14px; border-radius:10px; font-weight:600; cursor:pointer; white-space:nowrap; }
  button.ghost { background:#0e141b; color:var(--fg); border:1px solid #253244; padding:8px 10px; border-radius:10px; cursor:pointer; white-space:nowrap; }
  table { width:100%; border-collapse:collapse; white-space:nowrap; }
  .table-scroll { overflow-x:auto; max-width:100%; }
  th, td { border-bottom:1px solid #223146; padding:6px 8px; text-align:left; }
  th { color:#cfe6ff; font-weight:600; font-size:12px; }
  .muted { color:var(--muted); }
  .warn { color:var(--bad); }
  .ok { color:var(--good); }
  .tiny { font-size:12px; }
  .grid { display:grid; grid-template-columns: 1fr; gap:12px; }
  @media (min-width: 768px) {
    .grid { grid-template-columns: repeat(auto-fit, minmax(260px, 1fr)); }
  }
  .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; word-break:break-all; }
  pre { overflow-x:auto; max-width:100%; }
  .hint { color:#9fb1c1; font-size:12px; word-break:break-word; }
  .footer { padding:10px 16px; border-top:1px solid #18222f; color:#7ea2c7; font-size:11px; }
  @media (max-width: 640px) {
    header h1 { font-size:14px; }
    .hint { font-size:11px; }
    textarea { height:120px; font-size:13px; }
    button.primary, button.ghost { padding:8px 12px; font-size:13px; }
  }
  .question-interface { margin-top:16px; }
  .question-type { display:flex; gap:12px; margin-bottom:12px; flex-wrap:wrap; }
  .question-type button { flex:1; min-width:140px; }
  .question-form { display:none; }
  .question-form.active { display:block; }
  .answer-box { margin-top:12px; padding:12px; border-radius:8px; background:#0e141b; border:1px solid #253244; }
  .answer-shared { color:#42d392; font-weight:600; margin-bottom:8px; }
  .answer-private { color:#9fb1c1; font-size:12px; margin-top:8px; }
  .answer-private.hidden { filter: blur(8px); user-select: none; }
  .private-toggle { font-size:11px; padding:6px 12px; cursor:pointer; margin-top:8px; display:inline-block; }
  select.pill { padding:6px 10px; }
</style>
</head>
<body>
<header>
  <h1>Scenario Handler ‚Äî Offline SAT</h1>
  <span class="hint">Paste Mermaid-like graph, set constraints, then Generate.</span>
</header>

<div class="wrap">
  <section class="card">
    <h2>Map (Mermaid-like)</h2>
    <div class="hint tiny">Use undirected edges with <span class="mono">---</span>. Node IDs are room names (quote names with spaces).</div>
    <textarea id="mermaidInput">graph TD
  Foyer --- Stairs
  Foyer --- Gallery
  Gallery --- Stairs
  Gallery --- Masks
  Masks --- DanceRoom
  Masks --- MusicRoom
  MusicRoom --- DanceRoom</textarea>
    <div class="row">
      <label for="chars">Characters:</label>
      <input id="chars" class="pill" value="A, B, C, D, S, J" />
      <label for="steps">Timesteps (T):</label>
      <input id="steps" type="number" min="2" max="10" class="pill" value="6" />
    </div>
    <div class="row">
      <label>Movement:</label>
      <label><input type="checkbox" id="mustMove" checked /> Must move each time</label>
      <label><input type="checkbox" id="allowStay" /> Allow stay (overrides ‚Äúmust move‚Äù)</label>
    </div>
    <div class="row">
      <label for="seed">Seed:</label>
      <input id="seed" class="pill" value="0" />
      <button class="ghost" id="validateBtn">Validate Map</button>
    </div>

    <h2>Scenarios</h2>
    <div class="row">
      <label><input type="checkbox" id="s1" /> S1: Poison (assassin alone with victim, first char is assassin)</label>
    </div>
    <div class="row tiny">
      <label>Poison room (optional exact):</label>
      <input id="s1_room" class="pill" placeholder="e.g., Office" />
      <label>Poison time (1..T):</label>
      <input id="s1_time" class="pill" placeholder="e.g., 3" />
      <span class="muted tiny">(Assassin is always first character in list)</span>
    </div>
    <div class="row">
      <label><input type="checkbox" id="s2" /> S2: Phantom (one character is alone at every time)</label>
    </div>
    <div class="row">
      <label><input type="checkbox" id="s3" disabled /> S3: Jewels / hand-offs <span class="muted">(coming soon)</span></label>
    </div>
    <div class="row">
      <label><input type="checkbox" id="s4" /> S4: Bomb duo (two culprits are the <i>only pair ever alone together</i>)</label>
    </div>
    <div class="row">
      <label><input type="checkbox" id="s5" /> S5: Lovers (two lovers never meet / same room same time)</label>
    </div>

    <div class="row">
      <label>Difficulty percentile (0-100):</label>
      <input id="percentile" type="number" min="0" max="100" step="0.1" class="pill" value="50" />
      <label>Samples:</label>
      <input id="samples" type="number" min="10" max="5000" class="pill" value="100" />
    </div>
    <div class="row">
      <button class="primary" id="genBtn">Generate</button>
      <span id="status" class="hint"></span>
    </div>
  </section>

  <section class="card">
    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
      <h2 style="margin:0;">Results</h2>
      <button class="ghost" id="toggleResultsBtn" style="display:none;">‚ñº Collapse</button>
    </div>
    <div id="resultsHint" class="hint tiny">No results yet.</div>
    <div id="results" style="display:none">
      <div class="grid">
        <div class="card">
          <h2>Schedule (Characters √ó Time)</h2>
          <div id="schedule"></div>
        </div>
        <div class="card">
          <h2>Counts by Time</h2>
          <div id="byTime"></div>
        </div>
        <div class="card">
          <h2>Visits</h2>
          <div id="visits"></div>
        </div>
        <div class="card">
          <h2>Private Facts</h2>
          <div id="privateFacts"></div>
        </div>
        <div class="card">
          <h2>Raw JSON</h2>
          <pre class="mono tiny" id="rawJson"></pre>
          <button class="ghost" id="downloadBtn">Download JSON</button>
        </div>
      </div>
    </div>
  </section>

  <section class="card">
    <h2>Starting Information</h2>
    <div class="starting-info-interface">
      <div class="row">
        <label>Timestep:</label>
        <select id="startingTime" class="pill"></select>
        <label>Number of characters:</label>
        <input id="startingCharCount" type="number" min="1" max="10" class="pill" value="3" style="width:80px;" />
        <button class="primary" id="showStartingInfoBtn">Show Starting Positions</button>
      </div>
      <div id="startingInfoAnswer" class="answer-box" style="display:none;">
        <div class="answer-shared" id="startingInfoShared"></div>
      </div>
    </div>
  </section>

  <section class="card">
    <h2>Question Interface</h2>
    <div class="question-interface">
      <div class="question-type">
        <button class="ghost" id="askLocTimeBtn">Location + Time</button>
        <button class="ghost" id="askLocCharBtn">Location + Character</button>
      </div>
      
      <div id="locTimeForm" class="question-form">
        <div class="row">
          <label>Location:</label>
          <select id="locTimeLocation" class="pill"></select>
          <label>Time:</label>
          <select id="locTimeTime" class="pill"></select>
          <button class="primary" id="askLocTimeSubmit">Ask</button>
        </div>
        <div id="locTimeAnswer" class="answer-box" style="display:none;">
          <div class="answer-shared" id="locTimeShared"></div>
          <div>
            <button class="ghost private-toggle" id="locTimeToggle">üëÅÔ∏è Show</button>
          </div>
          <div class="answer-private hidden" id="locTimePrivate"></div>
        </div>
      </div>
      
      <div id="locCharForm" class="question-form">
        <div class="row">
          <label>Location:</label>
          <select id="locCharLocation" class="pill"></select>
          <label>Character:</label>
          <select id="locCharChar" class="pill"></select>
          <button class="primary" id="askLocCharSubmit">Ask</button>
        </div>
        <div id="locCharAnswer" class="answer-box" style="display:none;">
          <div class="answer-shared" id="locCharShared"></div>
          <div>
            <button class="ghost private-toggle" id="locCharToggle">üëÅÔ∏è Show</button>
          </div>
          <div class="answer-private hidden" id="locCharPrivate"></div>
        </div>
      </div>
    </div>
  </section>
</div>

<div class="footer tiny">SAT core: DPLL + unit propagation (pure JS). Scenarios supported: S1, S2, S4, S5.</div>

<script>
/* ===========================
   Minimal SAT (DPLL + Unit)
   =========================== */
function satSolve(clauses, numVars, randSeed=0, timeoutMs=5000) {
  // Clauses: array of arrays of ints, var IDs are 1..numVars, negative = negated
  // Returns: assignment array with 1..numVars: true/false, or null if UNSAT/timeout
  const rng = mulberry32(randSeed);
  const startTime = Date.now();
  let assigns = new Array(numVars+1).fill(0); // 0=unassigned, 1=true, -1=false
  let occPos = Array.from({length:numVars+1}, ()=>[]);
  let occNeg = Array.from({length:numVars+1}, ()=>[]);
  for (let i=0;i<clauses.length;i++){
    const c = clauses[i];
    for (const lit of c){
      const v = Math.abs(lit);
      if (lit>0) occPos[v].push(i); else occNeg[v].push(i);
    }
  }

  function unitProp(queue){
    while (queue.length){
      const lit = queue.pop();
      const v = Math.abs(lit);
      const val = lit>0 ? 1 : -1;
      if (assigns[v] !== 0){
        if (assigns[v] !== val) return false; // conflict
        continue;
      }
      assigns[v] = val;
      // Satisfy clauses containing lit
      const satList = val>0 ? occPos[v] : occNeg[v];
      for (const ci of satList){ clauses[ci] = [0]; } // mark satisfied
      // For clauses containing ~lit, remove ~lit
      const remList = val>0 ? occNeg[v] : occPos[v];
      for (const ci of remList){
        if (clauses[ci].length===1 && clauses[ci][0]===0) continue;
        // remove -lit
        let arr = clauses[ci];
        let idx = arr.indexOf(-lit);
        if (idx>=0){ arr.splice(idx,1); }
        if (arr.length===0) return false; // empty => conflict
        if (arr.length===1){
          const u = arr[0];
          if (u!==0) queue.push(u);
        }
      }
    }
    return true;
  }

  function chooseVar(){
    // Heuristic: pick variable from a random non-satisfied clause
    for (let tries=0; tries<1000; tries++){
      const ci = Math.floor(rng()*clauses.length);
      const c = clauses[ci];
      if (c.length===1 && c[0]===0) continue; // satisfied
      if (c.length>0){
        // pick literal with smallest abs assignment or random
        let lit = c[Math.floor(rng()*c.length)];
        return Math.abs(lit);
      }
    }
    // fallback
    for (let v=1; v<=numVars; v++) if (assigns[v]===0) return v;
    return 0;
  }

  // initial unit clauses
  let initQ = [];
  for (const c of clauses){ if (c.length===1 && c[0]!==0) initQ.push(c[0]); }
  if (!unitProp(initQ)) return null;

  function dfs(){
    // Check timeout
    if (Date.now() - startTime > timeoutMs) {
      throw new Error('SAT_TIMEOUT');
    }
    
    // check all satisfied?
    let allSat = true;
    for (const c of clauses){
      if (c.length===0) return false;
      if (!(c.length===1 && c[0]===0)) { allSat=false; break; }
    }
    if (allSat) return true;

    const v = chooseVar();
    if (v===0) return true; // nothing left
    // branch true, then false
    for (const tryVal of [true,false]){
      // clone state (clauses + assigns) cheaply via snapshots
      const snapshotClauses = clauses.map(c=>c.slice());
      const snapshotAssigns = assigns.slice();
      if (unitProp([tryVal ? v : -v])){
        if (dfs()) return true;
      }
      // restore
      clauses = snapshotClauses;
      assigns = snapshotAssigns;
    }
    return false;
  }

  try {
    if (!dfs()) return null;
  } catch (e) {
    if (e.message === 'SAT_TIMEOUT') return null;
    throw e;
  }

  // build boolean array
  const out = new Array(numVars+1);
  for (let v=1; v<=numVars; v++){
    out[v] = assigns[v]===1;
    if (assigns[v]===0) out[v]=false; // default
  }
  return out;
}
function mulberry32(a){return function(){var t=a+=0x6D2B79F5;t=Math.imul(t^t>>>15,t|1);t^=t+Math.imul(t^t>>>7,t|61);return ((t^t>>>14)>>>0)/4294967296;}}

/* ===========================
   CNF Builder Helpers
   =========================== */
function varPool(){
  let next = 1;
  const id = new Map();
  const rev = new Map();
  return {
    get(name){
      if (!id.has(name)){ id.set(name, next); rev.set(next, name); next++; }
      return id.get(name);
    },
    count(){ return next-1; },
    rev
  };
}
function atLeastOne(cl){ // OR over literals (already in int form)
  return [cl];
}
function atMostOne(vars){ // pairwise
  const out = [];
  for (let i=0;i<vars.length;i++) for (let j=i+1;j<vars.length;j++){
    out.push([-vars[i], -vars[j]]);
  }
  return out;
}
function exactlyOne(vars){
  return [...atLeastOne(vars), ...atMostOne(vars)];
}
function impl(aLit, bLit){ // a ‚áí b  ->  (-a ‚à® b)
  return [[-aLit, bLit]];
}

/* ===========================
   Mermaid-ish Parser
   =========================== */
function parseMermaid(txt){
  // Parse Mermaid-like graph: handle quoted and unquoted room names
  const rooms = new Set();
  const edges = [];
  // Match: optional quote, capture content, optional quote, ---, repeat
  const re = /"([^"]+)"|(\S+)/g;
  const lines = txt.split(/\r?\n/);
  for (let line of lines){
    line = line.trim();
    if (!line || line.startsWith("graph")) continue;
    if (!line.includes("---")) continue;
    
    // Extract all quoted or unquoted tokens
    const tokens = [];
    let match;
    while ((match = re.exec(line)) !== null) {
      tokens.push(match[1] || match[2]); // quoted or unquoted
    }
    
    // Find --- separator position in original line
    const parts = line.split("---");
    if (parts.length === 2) {
      // Re-parse each side
      const leftTokens = [];
      const rightTokens = [];
      re.lastIndex = 0;
      while ((match = re.exec(parts[0])) !== null) {
        leftTokens.push(match[1] || match[2]);
      }
      re.lastIndex = 0;
      while ((match = re.exec(parts[1])) !== null) {
        rightTokens.push(match[1] || match[2]);
      }
      
      if (leftTokens.length > 0 && rightTokens.length > 0) {
        const a = leftTokens[leftTokens.length - 1]; // last token on left
        const b = rightTokens[0]; // first token on right
        rooms.add(a); rooms.add(b);
        edges.push([a, b]);
      }
    }
  }
  return { rooms: Array.from(rooms), edges };
}
function neighbors(rooms, edges, includeSelf){
  const idx = new Map(); rooms.forEach((r,i)=>idx.set(r,i));
  const nbr = Array.from({length: rooms.length}, ()=> new Set());
  for (const [a,b] of edges){
    if (!idx.has(a) || !idx.has(b)) continue;
    const i = idx.get(a), j = idx.get(b);
    nbr[i].add(j); nbr[j].add(i);
  }
  if (includeSelf){ for (let i=0;i<rooms.length;i++) nbr[i].add(i); }
  return { idx, nbr: nbr.map(s=>Array.from(s)) };
}

/* ===========================
   Problem Encoding
   =========================== */
function buildCNF(config){
  // config: {rooms[], edges[], chars[], T, mustMove, allowStay, scenarios: {s1:{room?,time?}, s2, s4:{room?,time?}, s5}, seed}
  const vp = varPool();
  const clauses = [];

  const R = config.rooms, C = config.chars, T = config.T;
  const { idx: Ridx, nbr } = neighbors(R, config.edges, config.allowStay && !config.mustMove);

  // Helper to get variable IDs
  const X = (ci, t, ri) => vp.get(`X_${C[ci]}_${t}_${R[ri]}`);

  // Exactly one room per (c,t)
  for (let ci=0; ci<C.length; ci++){
    for (let t=0; t<T; t++){
      const vars = [];
      for (let ri=0; ri<R.length; ri++) vars.push(X(ci,t,ri));
      clauses.push(...exactlyOne(vars));
    }
  }

  // Movement constraints
  for (let ci=0; ci<C.length; ci++){
    for (let t=0; t<T-1; t++){
      for (let ri=0; ri<R.length; ri++){
        const allowed = nbr[ri];
        if (!config.allowStay && config.mustMove){
          // ensure next is in neighbors and not same room (we built nbr without self)
        }
        const rhs = allowed.map(r2 => X(ci, t+1, r2));
        // (¬¨X[c,t,ri] ‚à® (OR next))
        clauses.push([ -X(ci,t,ri), ...rhs ]);
      }
    }
  }

  // =========== Scenarios ===========
  const priv = {}; // which we'll fill later from assignment

  // S2: Phantom alone at every time
  let PH = null;
  if (config.scenarios.s2){
    PH = C.map((_,ci)=> vp.get(`PH_${C[ci]}`));
    clauses.push(...exactlyOne(PH));
    for (let t=0; t<T; t++){
      for (let ri=0; ri<R.length; ri++){
        for (let ci=0; ci<C.length; ci++){
          for (let cj=0; cj<C.length; cj++){
            if (ci===cj) continue;
            // (Ph(ci) ‚àß X(ci,t,ri)) ‚áí ¬¨X(cj,t,ri)
            clauses.push([ -PH[ci], -X(ci,t,ri), -X(cj,t,ri) ]);
          }
        }
      }
    }
    // Non-phantom characters must have at least one timestep where they're not alone
    for (let ci=0; ci<C.length; ci++){
      const atLeastOnceNotAlone = [];
      for (let t=0; t<T; t++){
        for (let ri=0; ri<R.length; ri++){
          for (let cj=0; cj<C.length; cj++){
            if (ci===cj) continue;
            // Variable: both ci and cj are in room ri at time t
            const bothThere = vp.get(`notAlone_${ci}_${t}_${ri}_${cj}`);
            // bothThere ‚áí X(ci,t,ri) and bothThere ‚áí X(cj,t,ri)
            clauses.push([-bothThere, X(ci,t,ri)]);
            clauses.push([-bothThere, X(cj,t,ri)]);
            // X(ci,t,ri) ‚àß X(cj,t,ri) ‚áí bothThere
            clauses.push([-X(ci,t,ri), -X(cj,t,ri), bothThere]);
            atLeastOnceNotAlone.push(bothThere);
          }
        }
      }
      // If ci is NOT the phantom, then at least one "not alone" moment must be true
      // ¬¨PH[ci] ‚áí (at least one bothThere is true)
      // CNF: PH[ci] ‚à® (OR of all bothThere vars)
      clauses.push([PH[ci], ...atLeastOnceNotAlone]);
    }
  }

  // S5: Lovers never meet (two distinct characters never share a room/time)
  let L1=null, L2=null;
  if (config.scenarios.s5){
    L1 = C.map((_,ci)=> vp.get(`L1_${C[ci]}`));
    L2 = C.map((_,ci)=> vp.get(`L2_${C[ci]}`));
    clauses.push(...exactlyOne(L1));
    clauses.push(...exactlyOne(L2));
    // distinct lovers: not the same char in both
    for (let ci=0; ci<C.length; ci++){ clauses.push([ -L1[ci], -L2[ci] ]); }
    
    // If both S2 and S5 are enabled, phantom cannot be a lover
    if (PH){
      for (let ci=0; ci<C.length; ci++){
        clauses.push([ -PH[ci], -L1[ci] ]);
        clauses.push([ -PH[ci], -L2[ci] ]);
      }
    }
    
    // Lovers never meet
    for (let t=0; t<T; t++){
      for (let ri=0; ri<R.length; ri++){
        for (let c1=0; c1<C.length; c1++){
          for (let c2=0; c2<C.length; c2++){
            if (c1===c2) continue;
            // (L1[c1] ‚àß L2[c2]) ‚áí ¬¨(X[c1,t,ri] ‚àß X[c2,t,ri])
            // CNF: ¬¨L1[c1] ‚à® ¬¨L2[c2] ‚à® ¬¨X[c1,t,ri] ‚à® ¬¨X[c2,t,ri]
            clauses.push([ -L1[c1], -L2[c2], -X(c1,t,ri), -X(c2,t,ri) ]);
          }
        }
      }
    }
    
    // Non-lovers must share a room with someone at least once
    for (let ci=0; ci<C.length; ci++){
      const atLeastOnceWithOthers = [];
      for (let t=0; t<T; t++){
        for (let ri=0; ri<R.length; ri++){
          for (let cj=0; cj<C.length; cj++){
            if (ci===cj) continue;
            // Create variable: both ci and cj in room ri at time t
            const withOther = vp.get(`loverNonAlone_${ci}_${t}_${ri}_${cj}`);
            // withOther ‚áî (X(ci,t,ri) ‚àß X(cj,t,ri))
            clauses.push([-withOther, X(ci,t,ri)]);
            clauses.push([-withOther, X(cj,t,ri)]);
            clauses.push([-X(ci,t,ri), -X(cj,t,ri), withOther]);
            atLeastOnceWithOthers.push(withOther);
          }
        }
      }
      // If NOT a lover, must have at least one "with others" moment
      // (L1[ci] ‚à® L2[ci]) ‚à® (at least one withOther is true)
      clauses.push([L1[ci], L2[ci], ...atLeastOnceWithOthers]);
    }
  }

  // S1: Poison ‚Äî assassin (first character) alone with exactly one victim
  let V=null, PT=null, PR=null;
  if (config.scenarios.s1){
    // Assassin is always first character (index 0)
    const assassinIdx = 0;
    
    // Variables for victim, poison time, and poison room
    V  = C.map((_,ci)=> vp.get(`V_${C[ci]}`));
    PT = Array.from({length:T}, (_,t)=> vp.get(`PT_${t}`));
    PR = R.map((_,ri)=> vp.get(`PR_${R[ri]}`));
    
    clauses.push(...exactlyOne(V));
    clauses.push(...exactlyOne(PT));
    clauses.push(...exactlyOne(PR));
    
    // Victim cannot be the assassin
    clauses.push([ -V[assassinIdx] ]);
    
    // Optional fixed room/time pins
    if (config.scenarios.s1_room){
      const ri = Ridx.get(config.scenarios.s1_room);
      if (ri!=null) clauses.push([ PR[ri] ]); // force true
    }
    if (config.scenarios.s1_time){
      const t = Number(config.scenarios.s1_time)-1;
      if (!Number.isNaN(t) && t>=0 && t<T) clauses.push([ PT[t] ]);
    }
    
    // At poison time/room: assassin and victim are there, no one else
    for (let t=0; t<T; t++){
      for (let ri=0; ri<R.length; ri++){
        for (let vi=0; vi<C.length; vi++){
          if (vi === assassinIdx) continue;
          
          // If PT[t] & PR[ri] & V[vi], then:
          // - Assassin is in room: X(assassin, t, ri)
          clauses.push([ -PT[t], -PR[ri], -V[vi], X(assassinIdx, t, ri) ]);
          // - Victim is in room: X(vi, t, ri)
          clauses.push([ -PT[t], -PR[ri], -V[vi], X(vi, t, ri) ]);
          
          // - No one else is in room
          for (let ci=0; ci<C.length; ci++){
            if (ci === assassinIdx || ci === vi) continue;
            clauses.push([ -PT[t], -PR[ri], -V[vi], -X(ci, t, ri) ]);
          }
        }
      }
    }
    
    // Assassin is ONLY alone with one other person at the poison time/room
    // For all other (t, ri) pairs, assassin must be either:
    // - Completely alone (no one else in room), OR
    // - With 2+ other people
    for (let t=0; t<T; t++){
      for (let ri=0; ri<R.length; ri++){
        // Create variable: this is the poison time/room
        const isPoisonMoment = vp.get(`isPoisonMoment_${t}_${ri}`);
        
        // isPoisonMoment is true iff there exists a victim such that PT[t] & PR[ri] & V[victim]
        const poisonClauses = [];
        for (let vi=0; vi<C.length; vi++){
          if (vi === assassinIdx) continue;
          const thisPoison = vp.get(`thisPoison_${t}_${ri}_${vi}`);
          // thisPoison <=> (PT[t] & PR[ri] & V[vi])
          clauses.push([-thisPoison, PT[t]]);
          clauses.push([-thisPoison, PR[ri]]);
          clauses.push([-thisPoison, V[vi]]);
          clauses.push([-PT[t], -PR[ri], -V[vi], thisPoison]);
          poisonClauses.push(thisPoison);
        }
        // isPoisonMoment <=> (OR of all thisPoison vars)
        clauses.push([-isPoisonMoment, ...poisonClauses]);
        for (const tp of poisonClauses){
          clauses.push([-tp, isPoisonMoment]);
        }
        
        // If assassin is in this room at this time AND it's NOT the poison moment,
        // then assassin must be either alone or with 2+ people (not exactly 1 other)
        
        // Count how many others are in room with assassin
        for (let ci=0; ci<C.length; ci++){
          if (ci === assassinIdx) continue;
          for (let cj=ci+1; cj<C.length; cj++){
            if (cj === assassinIdx) continue;
            
            // If assassin is here, NOT poison moment, and exactly ci and cj are the only others:
            // This should be impossible
            const exactlyTwo = vp.get(`exactlyTwo_${t}_${ri}_${ci}_${cj}`);
            
            // exactlyTwo => X(assassin), X(ci), X(cj), and no others
            clauses.push([-exactlyTwo, X(assassinIdx, t, ri)]);
            clauses.push([-exactlyTwo, X(ci, t, ri)]);
            clauses.push([-exactlyTwo, X(cj, t, ri)]);
            for (let ck=0; ck<C.length; ck++){
              if (ck === assassinIdx || ck === ci || ck === cj) continue;
              clauses.push([-exactlyTwo, -X(ck, t, ri)]);
            }
            
            // If all those conditions hold, then exactlyTwo
            const others = [];
            for (let ck=0; ck<C.length; ck++){
              if (ck === assassinIdx || ck === ci || ck === cj) continue;
              others.push(X(ck, t, ri));
            }
            clauses.push([exactlyTwo, -X(assassinIdx, t, ri), -X(ci, t, ri), -X(cj, t, ri), ...others]);
            
            // exactlyTwo AND NOT isPoisonMoment => FALSE (contradiction)
            clauses.push([-exactlyTwo, isPoisonMoment]);
          }
        }
        
        // Also handle case where assassin is with exactly 1 other person (not a pair from above)
        for (let ci=0; ci<C.length; ci++){
          if (ci === assassinIdx) continue;
          
          const exactlyOne = vp.get(`exactlyOne_${t}_${ri}_${ci}`);
          
          // exactlyOne => X(assassin), X(ci), and no others
          clauses.push([-exactlyOne, X(assassinIdx, t, ri)]);
          clauses.push([-exactlyOne, X(ci, t, ri)]);
          for (let ck=0; ck<C.length; ck++){
            if (ck === assassinIdx || ck === ci) continue;
            clauses.push([-exactlyOne, -X(ck, t, ri)]);
          }
          
          // If those conditions hold, then exactlyOne
          const others = [];
          for (let ck=0; ck<C.length; ck++){
            if (ck === assassinIdx || ck === ci) continue;
            others.push(X(ck, t, ri));
          }
          clauses.push([exactlyOne, -X(assassinIdx, t, ri), -X(ci, t, ri), ...others]);
          
          // exactlyOne AND NOT isPoisonMoment => FALSE
          clauses.push([-exactlyOne, isPoisonMoment]);
        }
      }
    }
  }

  // S4: Bomb duo ‚Äî A1 and A2 are the ONLY pair ever alone together (exactly 2 people in a room)
  let A1=null, A2=null;
  if (config.scenarios.s4){
    A1 = C.map((_,ci)=> vp.get(`A1_${C[ci]}`));
    A2 = C.map((_,ci)=> vp.get(`A2_${C[ci]}`));
    clauses.push(...exactlyOne(A1));
    clauses.push(...exactlyOne(A2));
    // distinct
    for (let ci=0; ci<C.length; ci++){ clauses.push([ -A1[ci], -A2[ci] ]); }

    // Enforce: ONLY A1 and A2 can ever be alone together (exactly 2 people in a room)
    // For all times and rooms, if exactly 2 people are present, they must be A1 and A2
    for (let t=0; t<T; t++){
      for (let ri=0; ri<R.length; ri++){
        // For each pair of characters
        for (let ci=0; ci<C.length; ci++){
          for (let cj=ci+1; cj<C.length; cj++){
            // If ci and cj are both in room ri at time t, and no one else is there,
            // then ci and cj must be A1 and A2 (in either order)
            
            // Create helper variable: exactly ci and cj in room ri at time t
            const exactlyTwo = vp.get(`exactlyTwo_${t}_${ri}_${ci}_${cj}`);
            
            // exactlyTwo => X(ci,t,ri) AND X(cj,t,ri)
            clauses.push([-exactlyTwo, X(ci,t,ri)]);
            clauses.push([-exactlyTwo, X(cj,t,ri)]);
            
            // exactlyTwo => no other character in room
            for (let ck=0; ck<C.length; ck++){
              if (ck === ci || ck === cj) continue;
              clauses.push([-exactlyTwo, -X(ck,t,ri)]);
            }
            
            // If X(ci,t,ri) AND X(cj,t,ri) AND (no others), then exactlyTwo
            // We need: (X(ci,t,ri) ‚àß X(cj,t,ri) ‚àß ‚àÄk‚â†ci,cj: ¬¨X(ck,t,ri)) => exactlyTwo
            // Equivalently: exactlyTwo ‚à® ¬¨X(ci,t,ri) ‚à® ¬¨X(cj,t,ri) ‚à® (‚àÉk: X(ck,t,ri))
            const someoneElse = [];
            for (let ck=0; ck<C.length; ck++){
              if (ck === ci || ck === cj) continue;
              someoneElse.push(X(ck,t,ri));
            }
            clauses.push([exactlyTwo, -X(ci,t,ri), -X(cj,t,ri), ...someoneElse]);
            
            // exactlyTwo => (ci,cj) must be (A1,A2) in some order
            // exactlyTwo => (A1[ci] ‚àß A2[cj]) ‚à® (A1[cj] ‚àß A2[ci])
            // CNF: exactlyTwo => pair1 ‚à® pair2
            const pair1 = vp.get(`pair1_${ci}_${cj}`);
            const pair2 = vp.get(`pair2_${ci}_${cj}`);
            
            // pair1 <=> (A1[ci] ‚àß A2[cj])
            clauses.push([-pair1, A1[ci]]);
            clauses.push([-pair1, A2[cj]]);
            clauses.push([-A1[ci], -A2[cj], pair1]);
            
            // pair2 <=> (A1[cj] ‚àß A2[ci])
            clauses.push([-pair2, A1[cj]]);
            clauses.push([-pair2, A2[ci]]);
            clauses.push([-A1[cj], -A2[ci], pair2]);
            
            // exactlyTwo => (pair1 ‚à® pair2)
            clauses.push([-exactlyTwo, pair1, pair2]);
          }
        }
      }
    }
    
    // Non-bombers must share a room with someone at least once
    for (let ci=0; ci<C.length; ci++){
      const atLeastOnceWithOthers = [];
      for (let t=0; t<T; t++){
        for (let ri=0; ri<R.length; ri++){
          for (let cj=0; cj<C.length; cj++){
            if (ci===cj) continue;
            // Create variable: both ci and cj in room ri at time t
            const withOther = vp.get(`bomberNonAlone_${ci}_${t}_${ri}_${cj}`);
            // withOther ‚áî (X(ci,t,ri) ‚àß X(cj,t,ri))
            clauses.push([-withOther, X(ci,t,ri)]);
            clauses.push([-withOther, X(cj,t,ri)]);
            clauses.push([-X(ci,t,ri), -X(cj,t,ri), withOther]);
            atLeastOnceWithOthers.push(withOther);
          }
        }
      }
      // If NOT a bomber, must have at least one "with others" moment
      // (A1[ci] ‚à® A2[ci]) ‚à® (at least one withOther is true)
      clauses.push([A1[ci], A2[ci], ...atLeastOnceWithOthers]);
    }
  }

  return { vp, clauses, privKeys: {PH, L1, L2, V, PT, PR, A1, A2} };
}

/* ===========================
   Scoring Functions
   =========================== */
function scoreScenario(res, cfg) {
  let score = 0;
  const scores = {};
  
  // S2: Phantom scoring
  if (cfg.scenarios.s2 && res.priv.phantom) {
    scores.phantom = scorePhantom(res, cfg);
    score += scores.phantom;
  }
  
  // S5: Lovers scoring
  if (cfg.scenarios.s5 && res.priv.lovers) {
    scores.lovers = scoreLovers(res, cfg);
    score += scores.lovers;
  }
  
  // S1: Poison scoring
  if (cfg.scenarios.s1 && res.priv.assassin) {
    scores.poison = scorePoison(res, cfg);
    score += scores.poison;
  }
  
  // S4: Bomb duo scoring
  if (cfg.scenarios.s4 && res.priv.bomb_duo) {
    scores.bomb = scoreBomb(res, cfg);
    score += scores.bomb;
  }
  
  return { total: score, breakdown: scores };
}

function scorePhantom(res, cfg) {
  // Higher score = harder puzzle
  // Measure: How many other characters are "almost phantom" (alone many times but not all)
  const phantom = res.priv.phantom;
  const T = cfg.T;
  const chars = cfg.chars;
  
  let score = 0;
  
  for (const char of chars) {
    if (char === phantom) continue;
    
    // Count how many times this character is alone
    let aloneCount = 0;
    for (let t = 0; t < T; t++) {
      const room = res.schedule[char][t];
      const othersInRoom = chars.filter(c => 
        c !== char && res.schedule[c][t] === room
      ).length;
      if (othersInRoom === 0) aloneCount++;
    }
    
    // Characters alone T-1 or T-2 times are "red herrings" - increase difficulty
    if (aloneCount >= T - 2) {
      score += 100 * (aloneCount / T); // Weight by proportion
    } else if (aloneCount >= T / 2) {
      score += 50 * (aloneCount / T); // Moderate red herrings
    }
  }
  
  return score;
}

function scoreLovers(res, cfg) {
  // Higher score = harder puzzle
  // Measure: How many other character pairs are "almost lovers" (rarely meet)
  const [lover1, lover2] = res.priv.lovers;
  const T = cfg.T;
  const chars = cfg.chars;
  
  let score = 0;
  
  // Check all other pairs
  for (let i = 0; i < chars.length; i++) {
    for (let j = i + 1; j < chars.length; j++) {
      const c1 = chars[i], c2 = chars[j];
      if ((c1 === lover1 && c2 === lover2) || (c1 === lover2 && c2 === lover1)) continue;
      
      // Count meetings
      let meetings = 0;
      for (let t = 0; t < T; t++) {
        if (res.schedule[c1][t] === res.schedule[c2][t]) meetings++;
      }
      
      // Pairs that meet 0-1 times are red herrings
      if (meetings === 0) score += 100;
      else if (meetings === 1) score += 80;
      else if (meetings <= 2) score += 40;
    }
  }
  
  return score;
}

function scorePoison(res, cfg) {
  // Higher score = harder puzzle
  // Measure: How many other pairs of characters are alone together at various times
  const assassin = res.priv.assassin;
  const victim = res.priv.victim;
  const poisonTime = res.priv.poison_time - 1; // 0-indexed
  const poisonRoom = res.priv.poison_room;
  const T = cfg.T;
  const chars = cfg.chars;
  
  let score = 0;
  
  // Count other pairs who are alone together (red herrings)
  for (let i = 0; i < chars.length; i++) {
    for (let j = i + 1; j < chars.length; j++) {
      const c1 = chars[i], c2 = chars[j];
      
      // Skip the actual assassin-victim pair at poison time
      if ((c1 === assassin && c2 === victim) || (c1 === victim && c2 === assassin)) {
        continue;
      }
      
      // Check if they're alone together at any time
      for (let t = 0; t < T; t++) {
        const room1 = res.schedule[c1][t];
        const room2 = res.schedule[c2][t];
        
        if (room1 === room2) {
          const othersInRoom = chars.filter(c => 
            c !== c1 && c !== c2 && res.schedule[c][t] === room1
          ).length;
          
          if (othersInRoom === 0) {
            // This pair is alone together - red herring
            score += 60;
          }
        }
      }
    }
  }
  
  return score;
}

function scoreBomb(res, cfg) {
  // Higher score = harder puzzle
  // Measure: How often bombers are with other people (camouflage)
  // and how many "near miss" groups of 3 exist
  const [bomber1, bomber2] = res.priv.bomb_duo;
  const plantTime = res.priv.plant_time - 1;
  const plantRoom = res.priv.plant_room;
  const T = cfg.T;
  const chars = cfg.chars;
  
  let score = 0;
  
  // Count times when bombers are together WITH other people (not alone)
  for (let t = 0; t < T; t++) {
    const room1 = res.schedule[bomber1][t];
    const room2 = res.schedule[bomber2][t];
    
    if (room1 === room2) {
      const othersInRoom = chars.filter(c => 
        c !== bomber1 && c !== bomber2 && res.schedule[c][t] === room1
      ).length;
      
      if (othersInRoom > 0) {
        // Bombers together but not alone - camouflage
        score += 40;
      }
    }
  }
  
  // Count "near miss" situations: groups of exactly 3 people
  // These are confusing because they're "almost" a suspicious pair
  for (let t = 0; t < T; t++) {
    for (const room of cfg.rooms) {
      const charsInRoom = chars.filter(c => res.schedule[c][t] === room);
      if (charsInRoom.length === 3) {
        score += 30; // Near-miss group
      }
    }
  }
  
  return score;
}

/* ===========================
   Decode & Clues
   =========================== */
function solveAndDecode(cfg){
  const { vp, clauses, privKeys } = buildCNF(cfg);
  const numVars = vp.count();
  const seed = Number(cfg.seed||0) || 0;
  const sol = satSolve(clauses, numVars, seed);
  if (!sol) return null;

  // Helper to read var by name
  const val = name => sol[ vp.get(name) ]===true;

  const R = cfg.rooms, C = cfg.chars, T = cfg.T;
  // schedule
  const schedule = {};
  for (let ci=0; ci<C.length; ci++){
    const row = [];
    for (let t=0; t<T; t++){
      let found = "(none)";
      for (let ri=0; ri<R.length; ri++){
        if (val(`X_${C[ci]}_${t}_${R[ri]}`)){ found = R[ri]; break; }
      }
      row.push(found);
    }
    schedule[C[ci]] = row;
  }

  // by-time counts
  const byTime = {};
  for (let t=0; t<T; t++){
    const counts = {}; R.forEach(r=>counts[r]=0);
    for (let ci=0; ci<C.length; ci++){
      const r = schedule[C[ci]][t];
      if (counts[r]!=null) counts[r]++;
    }
    byTime[t+1] = counts;
  }

  // visits
  const visits = {};
  for (let ci=0; ci<C.length; ci++){
    const v = {}; R.forEach(r=>v[r]=0);
    for (let t=0; t<T; t++){ v[ schedule[C[ci]][t] ]++; }
    visits[C[ci]] = v;
  }

  // private facts
  const priv = {};
  if (privKeys.PH){
    for (let ci=0; ci<C.length; ci++){
      if (val(`PH_${C[ci]}`)) { priv.phantom = C[ci]; break; }
    }
  }
  if (privKeys.L1 && privKeys.L2){
    let l1=null, l2=null;
    for (let ci=0; ci<C.length; ci++){
      if (val(`L1_${C[ci]}`)) l1 = C[ci];
      if (val(`L2_${C[ci]}`)) l2 = C[ci];
    }
    if (l1 && l2) priv.lovers = [l1,l2];
  }
  if (privKeys.V && privKeys.PT && privKeys.PR){
    let victim=null, pTime=null, pRoom=null;
    const assassin = C[0]; // First character is always assassin
    for (let ci=0; ci<C.length; ci++) if (val(`V_${C[ci]}`)) victim = C[ci];
    for (let t=0; t<T; t++) if (val(`PT_${t}`)) pTime = t+1;
    for (let ri=0; ri<R.length; ri++) if (val(`PR_${R[ri]}`)) pRoom = R[ri];
    priv.assassin = assassin; priv.victim = victim; priv.poison_time = pTime; priv.poison_room = pRoom;
  }
  if (privKeys.A1 && privKeys.A2){
    let a1=null, a2=null;
    for (let ci=0; ci<C.length; ci++){ if (val(`A1_${C[ci]}`)) a1=C[ci]; if (val(`A2_${C[ci]}`)) a2=C[ci]; }
    priv.bomb_duo = [a1,a2];
  }

  return { schedule, byTime, visits, priv, meta: { vars:numVars } };
}

/* ===========================
   UI glue
   =========================== */
function qs(id){ return document.getElementById(id); }
function renderTable(container, obj, headerLeft){
  const el = typeof container==="string"? qs(container) : container;
  let html = "<div class='table-scroll'><table><thead><tr>";
  if (headerLeft) html += `<th>${headerLeft}</th>`;
  const keys = Object.keys(obj);
  const isArrayRows = Array.isArray(obj[keys[0]]);
  const cols = isArrayRows ? obj[keys[0]].length : Object.keys(obj[keys[0]] || {}).length;
  if (isArrayRows){
    for (let i=0;i<cols;i++) html += `<th>t=${i+1}</th>`;
    html += "</tr></thead><tbody>";
    for (const rowKey of keys){
      html += `<tr><th>${rowKey}</th>`;
      for (const val of obj[rowKey]) html += `<td>${val}</td>`;
      html += `</tr>`;
    }
  } else {
    const subkeys = Object.keys(obj[keys[0]]||{});
    for (const sk of subkeys) html += `<th>${sk}</th>`;
    html += "</tr></thead><tbody>";
    for (const rowKey of keys){
      html += `<tr><th>${rowKey}</th>`;
      for (const sk of subkeys) html += `<td>${obj[rowKey][sk]}</td>`;
      html += `</tr>`;
    }
  }
  html += "</tbody></table></div>";
  el.innerHTML = html;
}

qs("validateBtn").addEventListener("click", ()=>{
  const {rooms, edges} = parseMermaid(qs("mermaidInput").value);
  const msg = (rooms.length>=2 && edges.length>=1)
    ? `<span class="ok">OK:</span> ${rooms.length} rooms, ${edges.length} doors`
    : `<span class="warn">Need ‚â•2 rooms and ‚â•1 door.</span>`;
  qs("status").innerHTML = msg;
});

qs("genBtn").addEventListener("click", async ()=>{
  const percentile = Number(qs("percentile").value);
  const sampleCount = Number(qs("samples").value) || 100;
  
  qs("status").textContent = `Generating ${sampleCount} scenarios‚Ä¶`;
  
  const {rooms, edges} = parseMermaid(qs("mermaidInput").value);
  const chars = qs("chars").value.split(",").map(s=>s.trim()).filter(Boolean);
  const T = Math.max(2, Math.min(10, Number(qs("steps").value)||6));
  const mustMove = qs("mustMove").checked;
  const allowStay = qs("allowStay").checked;

  if (rooms.length<2 || edges.length<1){ qs("status").innerHTML = `<span class="warn">Map too small.</span>`; return; }
  if (chars.length<2){ qs("status").innerHTML = `<span class="warn">Add at least 2 characters.</span>`; return; }

  const cfg = {
    rooms, edges, chars, T, mustMove, allowStay,
    scenarios: {
      s1: qs("s1").checked,
      s2: qs("s2").checked,
      s3: false, // placeholder
      s4: qs("s4").checked,
      s5: qs("s5").checked,
      s1_room: qs("s1_room").value.trim() || null,
      s1_time: qs("s1_time").value.trim() || null
    }
  };

  try{
    // Multi-generation with scoring
    const solutions = [];
    let skipped = 0;
    
    for (let i = 0; i < sampleCount; i++) {
      cfg.seed = i;
      try {
        const res = solveAndDecode(cfg);
        if (res) {
          const scored = { ...res, score: scoreScenario(res, cfg) };
          solutions.push(scored);
        } else {
          skipped++;
        }
      } catch (e) {
        // Skip timeouts or other errors
        skipped++;
        console.warn(`Sample ${i} failed:`, e.message);
      }
      
      if (i % 10 === 0) {
        qs("status").textContent = `Generated ${i}/${sampleCount} (${solutions.length} valid, ${skipped} skipped)...`;
        await new Promise(r => setTimeout(r, 0)); // Allow UI update
      }
    }
    
    if (solutions.length === 0) {
      qs("status").innerHTML = `<span class="warn">No solutions found (${skipped} samples timed out or failed).</span>`;
      return;
    }
    
    // Sort by score (ascending - lower scores are easier)
    solutions.sort((a, b) => a.score.total - b.score.total);
    
    // Select solution at the specified percentile
    const targetIdx = Math.floor((percentile / 100) * (solutions.length - 1));
    const res = solutions[targetIdx];
    
    qs("status").innerHTML = `<span class="ok">Selected ${percentile}th percentile scenario</span> (score: ${res.score.total.toFixed(1)}, rank ${targetIdx+1}/${solutions.length}, ${skipped} skipped)`;
    // Display selected solution
    qs("resultsHint").style.display = "none";
    qs("results").style.display = "block";
    qs("toggleResultsBtn").style.display = "inline-block";
    renderTable("schedule", res.schedule, "Character");
    renderTable("byTime", res.byTime, "Time");
    renderTable("visits", res.visits, "Character");

    // Private facts
    const pf = [];
    if (res.priv.phantom) pf.push(`<div>Phantom: <b>${res.priv.phantom}</b></div>`);
    if (res.priv.lovers) pf.push(`<div>Lovers: <b>${res.priv.lovers[0]}</b> + <b>${res.priv.lovers[1]}</b></div>`);
    if (res.priv.assassin) pf.push(`<div>Assassin: <b>${res.priv.assassin}</b> poisoned <b>${res.priv.victim}</b> @ t=${res.priv.poison_time}, room=${res.priv.poison_room}</div>`);
    if (res.priv.bomb_duo) pf.push(`<div>Bomb duo: <b>${res.priv.bomb_duo[0]}</b> + <b>${res.priv.bomb_duo[1]}</b></div>`);
    if (pf.length===0) pf.push(`<div class="muted">None</div>`);
    qs("privateFacts").innerHTML = pf.join("");

    const raw = { schedule: res.schedule, by_time: res.byTime, visits: res.visits, private: res.priv, meta: res.meta };
    qs("rawJson").textContent = JSON.stringify(raw, null, 2);

    qs("downloadBtn").onclick = ()=>{
      const blob = new Blob([JSON.stringify(raw,null,2)], {type:"application/json"});
      const a = document.createElement("a");
      a.href = URL.createObjectURL(blob);
      a.download = "scenario_solution.json";
      a.click();
      URL.revokeObjectURL(a.href);
    };

    // Setup question interface
    setupQuestionInterface(res, cfg);
  }catch(e){
    console.error(e);
    qs("status").innerHTML = `<span class="warn">Error: ${e.message}</span>`;
  }
});

function setupQuestionInterface(res, cfg){
  const rooms = cfg.rooms;
  const chars = cfg.chars;
  const T = cfg.T;

  // Populate dropdowns
  const locTimeLocation = qs("locTimeLocation");
  const locCharLocation = qs("locCharLocation");
  const locCharChar = qs("locCharChar");
  const locTimeTime = qs("locTimeTime");
  const startingTime = qs("startingTime");

  locTimeLocation.innerHTML = rooms.map(r => `<option value="${r}">${r}</option>`).join("");
  locCharLocation.innerHTML = rooms.map(r => `<option value="${r}">${r}</option>`).join("");
  locCharChar.innerHTML = chars.map(c => `<option value="${c}">${c}</option>`).join("");
  locTimeTime.innerHTML = Array.from({length:T}, (_,i) => `<option value="${i+1}">t=${i+1}</option>`).join("");
  startingTime.innerHTML = Array.from({length:T}, (_,i) => `<option value="${i+1}"${i===0?' selected':''}>t=${i+1}</option>`).join("");

  // Toggle between question types
  qs("askLocTimeBtn").onclick = ()=>{
    qs("locTimeForm").classList.add("active");
    qs("locCharForm").classList.remove("active");
    qs("locTimeAnswer").style.display = "none";
  };
  qs("askLocCharBtn").onclick = ()=>{
    qs("locCharForm").classList.add("active");
    qs("locTimeForm").classList.remove("active");
    qs("locCharAnswer").style.display = "none";
  };

  // Location + Time question
  qs("askLocTimeSubmit").onclick = ()=>{
    const location = locTimeLocation.value;
    const time = Number(locTimeTime.value);
    
    // Count how many characters were in this location at this time
    const charsAtLocation = [];
    for (const char of chars){
      if (res.schedule[char][time-1] === location){
        charsAtLocation.push(char);
      }
    }
    
    const count = charsAtLocation.length;
    
    // Deterministically pick one character to reveal (based on location + time hash)
    let revealedChar = "none";
    if (count > 0) {
      // Simple hash: sum char codes of location + time
      let hash = time;
      for (let i = 0; i < location.length; i++) {
        hash = (hash * 31 + location.charCodeAt(i)) & 0x7fffffff;
      }
      const idx = hash % charsAtLocation.length;
      revealedChar = charsAtLocation[idx];
    }
    
    qs("locTimeShared").innerHTML = `üü¢ Shared: <b>${count}</b> character${count===1?'':'s'} ${count===1?'was':'were'} in ${location} at t=${time}`;
    qs("locTimePrivate").innerHTML = `‚ö™ Private: One character present: <b>${revealedChar}</b>`;
    qs("locTimePrivate").classList.add("hidden");
    qs("locTimeToggle").textContent = "üëÅÔ∏è Show";
    qs("locTimeAnswer").style.display = "block";
    
    // Setup toggle handler
    qs("locTimeToggle").onclick = ()=>{
      const privateEl = qs("locTimePrivate");
      const btn = qs("locTimeToggle");
      if (privateEl.classList.contains("hidden")) {
        privateEl.classList.remove("hidden");
        btn.textContent = "üëÅÔ∏è Hide";
      } else {
        privateEl.classList.add("hidden");
        btn.textContent = "üëÅÔ∏è Show";
      }
    };
  };

  // Location + Character question
  qs("askLocCharSubmit").onclick = ()=>{
    const location = locCharLocation.value;
    const character = locCharChar.value;
    
    // Count how many times this character visited this location
    const visitCount = res.visits[character][location] || 0;
    
    // Find which times they visited
    const times = [];
    for (let t=0; t<T; t++){
      if (res.schedule[character][t] === location){
        times.push(t+1);
      }
    }
    
    // Deterministically pick one time to reveal (based on location + character hash)
    let revealedTime = "never";
    if (times.length > 0) {
      // Simple hash: sum char codes of location + character
      let hash = 0;
      for (let i = 0; i < location.length; i++) {
        hash = (hash * 31 + location.charCodeAt(i)) & 0x7fffffff;
      }
      for (let i = 0; i < character.length; i++) {
        hash = (hash * 31 + character.charCodeAt(i)) & 0x7fffffff;
      }
      const idx = hash % times.length;
      revealedTime = `t=${times[idx]}`;
    }
    
    qs("locCharShared").innerHTML = `üü¢ Shared: <b>${visitCount}</b> visit${visitCount===1?'':'s'} by ${character} to ${location}`;
    qs("locCharPrivate").innerHTML = `‚ö™ Private: One time visited: <b>${revealedTime}</b>`;
    qs("locCharPrivate").classList.add("hidden");
    qs("locCharToggle").textContent = "üëÅÔ∏è Show";
    qs("locCharAnswer").style.display = "block";
    
    // Setup toggle handler
    qs("locCharToggle").onclick = ()=>{
      const privateEl = qs("locCharPrivate");
      const btn = qs("locCharToggle");
      if (privateEl.classList.contains("hidden")) {
        privateEl.classList.remove("hidden");
        btn.textContent = "üëÅÔ∏è Hide";
      } else {
        privateEl.classList.add("hidden");
        btn.textContent = "üëÅÔ∏è Show";
      }
    };
  };

  // Starting Information handler
  qs("showStartingInfoBtn").onclick = ()=>{
    const time = Number(startingTime.value);
    const charCount = Math.min(chars.length, Math.max(1, Number(qs("startingCharCount").value) || 3));
    
    // Deterministically select characters based on time (for consistency)
    // Use a simple hash to pick characters
    let hash = time * 7919; // Prime number for better distribution
    const selectedChars = [];
    const availableChars = [...chars];
    
    for (let i = 0; i < charCount && availableChars.length > 0; i++) {
      hash = (hash * 31 + i) & 0x7fffffff;
      const idx = hash % availableChars.length;
      selectedChars.push(availableChars[idx]);
      availableChars.splice(idx, 1);
    }
    
    // Get locations for selected characters at the specified time
    const locations = selectedChars.map(char => {
      const location = res.schedule[char][time-1];
      return `<b>${char}</b>: ${location}`;
    });
    
    qs("startingInfoShared").innerHTML = `üü¢ At t=${time}, the following character locations are revealed:<br/><br/>` + locations.join('<br/>');
    qs("startingInfoAnswer").style.display = "block";
  };

  // Default to Location + Time
  qs("askLocTimeBtn").click();
}

// Toggle results collapse/expand
qs("toggleResultsBtn").addEventListener("click", ()=>{
  const resultsDiv = qs("results");
  const btn = qs("toggleResultsBtn");
  if (resultsDiv.style.display === "none") {
    resultsDiv.style.display = "block";
    btn.textContent = "‚ñº Collapse";
  } else {
    resultsDiv.style.display = "none";
    btn.textContent = "‚ñ∂ Expand";
  }
});
</script>
</body>
</html>

