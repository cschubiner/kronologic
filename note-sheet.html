<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Kronologic Note Sheet</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<script src="https://unpkg.com/cytoscape@3.26.0/dist/cytoscape.min.js"></script>
<style>
  :root {
    --bg: #0b0f14;
    --fg: #e6edf3;
    --muted: #9fb1c1;
    --accent: #4da3ff;
    --card: #121821;
    --border: #18222f;
    --input-bg: #0e141b;
    --input-border: #253244;
  }
  
  * { box-sizing: border-box; }
  
  body {
    margin: 0;
    background: var(--bg);
    color: var(--fg);
    font: 14px/1.45 system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial;
    padding: 16px;
  }
  
  header {
    margin-bottom: 16px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    flex-wrap: wrap;
    gap: 12px;
  }
  
  header h1 {
    margin: 0;
    font-size: 18px;
    color: #cfe6ff;
  }
  
  .controls {
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
  }
  
  button {
    background: var(--input-bg);
    color: var(--fg);
    border: 1px solid var(--input-border);
    padding: 8px 12px;
    border-radius: 8px;
    cursor: pointer;
    font: inherit;
    font-size: 13px;
  }
  
  button:hover {
    background: #1a2332;
  }
  
  button.primary {
    background: var(--accent);
    color: #001122;
    border: none;
    font-weight: 600;
  }
  
  /* Time-step maps grid */
  .timestep-grid {
    display: grid;
    gap: 12px;
    margin-bottom: 20px;
  }
  
  /* Responsive columns based on timestep count */
  .timestep-grid.cols-4 { grid-template-columns: repeat(4, 1fr); }
  .timestep-grid.cols-3 { grid-template-columns: repeat(3, 1fr); }
  .timestep-grid.cols-2 { grid-template-columns: repeat(2, 1fr); }
  
  @media (max-width: 1200px) {
    .timestep-grid.cols-4 { grid-template-columns: repeat(3, 1fr); }
  }
  
  @media (max-width: 900px) {
    .timestep-grid.cols-4,
    .timestep-grid.cols-3 { grid-template-columns: repeat(2, 1fr); }
  }
  
  @media (max-width: 600px) {
    .timestep-grid { grid-template-columns: 1fr; }
  }
  
  .map-card {
    background: var(--card);
    border: 1px solid var(--border);
    border-radius: 12px;
    overflow: hidden;
  }
  
  .map-header {
    padding: 10px 12px;
    background: #0e141b;
    border-bottom: 1px solid var(--border);
    font-weight: 600;
    font-size: 13px;
    color: #cfe6ff;
    text-align: center;
  }
  
  .map-container {
    width: 100%;
    height: 250px;
    position: relative;
  }
  
  /* Character tracking table */
  .tracking-section {
    background: var(--card);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 16px;
    margin-bottom: 20px;
  }
  
  .tracking-section h2 {
    margin: 0 0 12px;
    font-size: 14px;
    color: #cfe6ff;
  }
  
  .tracking-table {
    width: 100%;
    border-collapse: collapse;
    overflow-x: auto;
    display: block;
  }
  
  .tracking-table thead,
  .tracking-table tbody {
    display: table;
    width: 100%;
    table-layout: fixed;
  }
  
  .tracking-table th,
  .tracking-table td {
    padding: 8px;
    text-align: center;
    border-bottom: 1px solid var(--border);
    font-size: 13px;
  }
  
  .tracking-table th {
    background: #0e141b;
    color: #cfe6ff;
    font-weight: 600;
    position: sticky;
    top: 0;
  }
  
  .tracking-table th:first-child,
  .tracking-table td:first-child {
    text-align: left;
    font-weight: 600;
  }
  
  .tracking-table input {
    width: 50px;
    background: var(--input-bg);
    border: 1px solid var(--input-border);
    color: var(--fg);
    padding: 4px 6px;
    border-radius: 6px;
    text-align: center;
    font: inherit;
    font-size: 13px;
  }
  
  /* Notes area */
  .notes-section {
    background: var(--card);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 16px;
  }
  
  .notes-section h2 {
    margin: 0 0 12px;
    font-size: 14px;
    color: #cfe6ff;
  }
  
  .notes-toolbar {
    display: flex;
    gap: 4px;
    margin-bottom: 8px;
    flex-wrap: wrap;
  }
  
  .notes-toolbar button {
    padding: 6px 10px;
    font-size: 12px;
  }
  
  #notesEditor {
    width: 100%;
    min-height: 200px;
    background: var(--input-bg);
    border: 1px solid var(--input-border);
    border-radius: 8px;
    padding: 12px;
    color: var(--fg);
    font: inherit;
    line-height: 1.6;
    resize: vertical;
  }
  
  /* Character selector popup */
  .popup-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.7);
    display: none;
    align-items: center;
    justify-content: center;
    z-index: 1000;
  }
  
  .popup-overlay.active {
    display: flex;
  }
  
  .popup-content {
    background: var(--card);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 20px;
    max-width: 400px;
    width: 90%;
    max-height: 80vh;
    overflow-y: auto;
  }
  
  .popup-header {
    font-size: 14px;
    font-weight: 600;
    color: #cfe6ff;
    margin-bottom: 16px;
  }
  
  .character-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
    gap: 8px;
    margin-bottom: 16px;
  }
  
  .character-option {
    background: var(--input-bg);
    border: 2px solid var(--input-border);
    border-radius: 8px;
    padding: 12px 8px;
    cursor: pointer;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 4px;
    transition: all 0.2s;
  }
  
  .character-option:hover {
    background: #1a2332;
    transform: translateY(-2px);
  }
  
  .character-option .initial {
    font-size: 20px;
    font-weight: 700;
  }
  
  .character-option .name {
    font-size: 11px;
    color: var(--muted);
  }
  
  .current-chips {
    margin-bottom: 12px;
  }
  
  .current-chips-label {
    font-size: 12px;
    color: var(--muted);
    margin-bottom: 6px;
  }
  
  .chip-list {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
  }
  
  .chip {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    padding: 6px 10px;
    border-radius: 999px;
    font-size: 12px;
    font-weight: 600;
    cursor: pointer;
    border: 2px solid;
  }
  
  .chip.strikethrough {
    text-decoration: line-through;
    opacity: 0.6;
  }
  
  .chip .remove {
    cursor: pointer;
    opacity: 0.7;
    font-weight: 700;
  }
  
  .chip .remove:hover {
    opacity: 1;
  }
  
  .popup-actions {
    display: flex;
    gap: 8px;
    justify-content: flex-end;
  }
  
  /* Cytoscape node styling for chips */
  .cy-node-chips {
    position: absolute;
    bottom: 2px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 2px;
    pointer-events: none;
  }
  
  .cy-node-chip {
    background: white;
    border: 1px solid;
    border-radius: 3px;
    padding: 1px 3px;
    font-size: 8px;
    font-weight: 700;
  }
  
  .cy-node-chip.strikethrough {
    text-decoration: line-through;
    opacity: 0.6;
  }
  
  .hint {
    color: var(--muted);
    font-size: 12px;
    margin-top: 8px;
  }
</style>
</head>
<body>

<header>
  <h1>Kronologic Note Sheet</h1>
  <div class="controls">
    <button id="undoBtn" title="Undo (Ctrl+Z)">↶ Undo</button>
    <button id="redoBtn" title="Redo (Ctrl+Y)">↷ Redo</button>
    <button id="clearBtn">Clear All</button>
    <button id="exportBtn" class="primary">Export Notes</button>
  </div>
</header>

<div class="timestep-grid" id="timestepGrid">
  <!-- Time-step map cards will be generated here -->
</div>

<div class="tracking-section">
  <h2>Character Visit Tracking</h2>
  <div style="overflow-x: auto;">
    <table class="tracking-table" id="trackingTable">
      <thead>
        <tr>
          <th>Character</th>
          <!-- Room columns will be generated -->
        </tr>
      </thead>
      <tbody>
        <!-- Character rows will be generated -->
      </tbody>
    </table>
  </div>
</div>

<div class="notes-section">
  <h2>Deduction Notes</h2>
  <div class="notes-toolbar">
    <button onclick="document.execCommand('bold')"><b>B</b></button>
    <button onclick="document.execCommand('italic')"><i>I</i></button>
    <button onclick="document.execCommand('insertUnorderedList')">• List</button>
    <button onclick="document.execCommand('insertOrderedList')">1. List</button>
  </div>
  <div id="notesEditor" contenteditable="true" spellcheck="true">
    <p>Start taking notes here...</p>
  </div>
  <div class="hint">Use the toolbar to format your deduction notes. All changes are saved automatically.</div>
</div>

<!-- Character selector popup -->
<div class="popup-overlay" id="charPopup">
  <div class="popup-content">
    <div class="popup-header" id="popupHeader">Select Character</div>
    
    <div class="current-chips" id="currentChipsSection" style="display: none;">
      <div class="current-chips-label">Current placements:</div>
      <div class="chip-list" id="currentChipsList"></div>
    </div>
    
    <div class="character-grid" id="characterGrid">
      <!-- Character options will be generated -->
    </div>
    
    <div class="popup-actions">
      <button id="popupClose">Close</button>
    </div>
  </div>
</div>

<script>
// State management
const state = {
  rooms: [],
  characters: [],
  timesteps: 6,
  graphElements: [],
  graphLayout: null,
  placements: {}, // { timestep: { room: [{ char, initial, color, strikethrough }] } }
  visitCounts: {}, // { char: { room: count } }
  history: [],
  historyIndex: -1,
  cyInstances: {} // { timestep: cytoscape instance }
};

// Character colors
const characterColors = [
  '#3b82f6', '#ef4444', '#10b981', '#f59e0b', '#8b5cf6',
  '#ec4899', '#06b6d4', '#84cc16', '#f97316', '#6366f1'
];

// Initialize from scenario data (would come from main generator)
function initializeFromScenario(scenarioData) {
  state.rooms = scenarioData.rooms;
  state.characters = scenarioData.characters.map((name, i) => ({
    name,
    initial: name[0].toUpperCase(),
    color: characterColors[i % characterColors.length]
  }));
  state.timesteps = scenarioData.timesteps;
  state.graphElements = scenarioData.graphElements;
  state.graphLayout = scenarioData.graphLayout;
  
  // Initialize placements
  for (let t = 1; t <= state.timesteps; t++) {
    state.placements[t] = {};
    state.rooms.forEach(room => {
      state.placements[t][room] = [];
    });
  }
  
  // Initialize visit counts
  state.characters.forEach(char => {
    state.visitCounts[char.name] = {};
    state.rooms.forEach(room => {
      state.visitCounts[char.name][room] = '';
    });
  });
  
  render();
  saveState();
}

// Render all components
function render() {
  renderTimestepGrid();
  renderTrackingTable();
  updateUndoRedoButtons();
}

// Render timestep grid
function renderTimestepGrid() {
  const grid = document.getElementById('timestepGrid');
  
  // Determine column layout
  let colClass = 'cols-4';
  if (state.timesteps <= 4) colClass = 'cols-4';
  else if (state.timesteps <= 6) colClass = 'cols-3';
  else colClass = 'cols-4';
  
  grid.className = `timestep-grid ${colClass}`;
  grid.innerHTML = '';
  
  for (let t = 1; t <= state.timesteps; t++) {
    const card = document.createElement('div');
    card.className = 'map-card';
    
    const header = document.createElement('div');
    header.className = 'map-header';
    header.textContent = `Time ${t}`;
    
    const container = document.createElement('div');
    container.className = 'map-container';
    container.id = `map-time-${t}`;
    
    card.appendChild(header);
    card.appendChild(container);
    grid.appendChild(card);
    
    // Render cytoscape graph
    renderMiniMap(t);
  }
}

// Render individual mini-map
function renderMiniMap(timestep) {
  setTimeout(() => {
    const container = document.getElementById(`map-time-${timestep}`);
    if (!container) return;
    
    // Create cytoscape instance
    const cy = cytoscape({
      container: container,
      elements: JSON.parse(JSON.stringify(state.graphElements)),
      layout: state.graphLayout || {
        name: 'circle',
        fit: true,
        padding: 20
      },
      style: [
        {
          selector: 'node',
          style: {
            'label': 'data(name)',
            'font-size': '10px',
            'text-valign': 'top',
            'text-halign': 'center',
            'text-margin-y': -5,
            'background-color': '#ffffff',
            'border-width': 2,
            'border-color': '#253244',
            'width': 50,
            'height': 50,
            'color': '#0b0f14',
            'font-weight': 600
          }
        },
        {
          selector: 'edge',
          style: {
            'width': 2,
            'line-color': '#253244',
            'curve-style': 'bezier'
          }
        }
      ],
      autoungrabify: true,
      userZoomingEnabled: false,
      userPanningEnabled: false,
      boxSelectionEnabled: false
    });
    
    state.cyInstances[timestep] = cy;
    
    // Add click handler to nodes
    cy.on('tap', 'node', (evt) => {
      const node = evt.target;
      const roomName = node.data('name');
      openCharacterSelector(timestep, roomName);
    });
    
    // Update node visuals based on placements
    updateNodeVisuals(timestep);
  }, 0);
}

// Update node visuals with character chips
function updateNodeVisuals(timestep) {
  const cy = state.cyInstances[timestep];
  if (!cy) return;
  
  cy.nodes().forEach(node => {
    const roomName = node.data('name');
    const placements = state.placements[timestep][roomName] || [];
    
    // Update border color based on placements
    if (placements.length > 0) {
      const hasNonStrikethrough = placements.some(p => !p.strikethrough);
      if (hasNonStrikethrough) {
        node.style('border-color', placements[0].color);
        node.style('border-width', 3);
      } else {
        node.style('border-color', '#ef4444');
        node.style('border-width', 3);
      }
    } else {
      node.style('border-color', '#253244');
      node.style('border-width', 2);
    }
    
    // Add label with initials
    if (placements.length > 0) {
      const initials = placements.map(p => 
        p.strikethrough ? `${p.initial}̶` : p.initial
      ).join(' ');
      node.data('label', `${roomName}\n${initials}`);
      node.style('label', 'data(label)');
    } else {
      node.style('label', roomName);
    }
  });
}

// Open character selector popup
function openCharacterSelector(timestep, roomName) {
  const popup = document.getElementById('charPopup');
  const header = document.getElementById('popupHeader');
  const grid = document.getElementById('characterGrid');
  const currentSection = document.getElementById('currentChipsSection');
  const currentList = document.getElementById('currentChipsList');
  
  header.textContent = `${roomName} at Time ${timestep}`;
  
  // Show current placements
  const placements = state.placements[timestep][roomName] || [];
  if (placements.length > 0) {
    currentSection.style.display = 'block';
    currentList.innerHTML = placements.map(p => `
      <div class="chip ${p.strikethrough ? 'strikethrough' : ''}" 
           style="border-color: ${p.color}; color: ${p.color};"
           onclick="toggleStrikethrough(${timestep}, '${roomName}', '${p.char}')">
        ${p.initial}
        <span class="remove" onclick="event.stopPropagation(); removeChip(${timestep}, '${roomName}', '${p.char}')">×</span>
      </div>
    `).join('');
  } else {
    currentSection.style.display = 'none';
  }
  
  // Show character options
  grid.innerHTML = state.characters.map(char => `
    <button class="character-option" 
            style="border-color: ${char.color};"
            onclick="addCharacter(${timestep}, '${roomName}', '${char.name}')">
      <span class="initial" style="color: ${char.color};">${char.initial}</span>
      <span class="name">${char.name}</span>
    </button>
  `).join('');
  
  popup.classList.add('active');
}

// Add character to room
function addCharacter(timestep, roomName, charName) {
  const char = state.characters.find(c => c.name === charName);
  const placements = state.placements[timestep][roomName];
  
  // Check if already placed
  if (placements.some(p => p.char === charName)) {
    return;
  }
  
  placements.push({
    char: charName,
    initial: char.initial,
    color: char.color,
    strikethrough: false
  });
  
  updateNodeVisuals(timestep);
  openCharacterSelector(timestep, roomName); // Refresh popup
  saveState();
}

// Toggle strikethrough
function toggleStrikethrough(timestep, roomName, charName) {
  const placements = state.placements[timestep][roomName];
  const placement = placements.find(p => p.char === charName);
  if (placement) {
    placement.strikethrough = !placement.strikethrough;
    updateNodeVisuals(timestep);
    openCharacterSelector(timestep, roomName); // Refresh popup
    saveState();
  }
}

// Remove chip
function removeChip(timestep, roomName, charName) {
  const placements = state.placements[timestep][roomName];
  const index = placements.findIndex(p => p.char === charName);
  if (index >= 0) {
    placements.splice(index, 1);
    updateNodeVisuals(timestep);
    openCharacterSelector(timestep, roomName); // Refresh popup
    saveState();
  }
}

// Close popup
document.getElementById('popupClose').addEventListener('click', () => {
  document.getElementById('charPopup').classList.remove('active');
});

// Close popup on overlay click
document.getElementById('charPopup').addEventListener('click', (e) => {
  if (e.target.id === 'charPopup') {
    document.getElementById('charPopup').classList.remove('active');
  }
});

// Render tracking table
function renderTrackingTable() {
  const table = document.getElementById('trackingTable');
  const thead = table.querySelector('thead tr');
  const tbody = table.querySelector('tbody');
  
  // Header
  thead.innerHTML = '<th>Character</th>' + 
    state.rooms.map(room => `<th>${room}</th>`).join('');
  
  // Rows
  tbody.innerHTML = state.characters.map(char => `
    <tr>
      <td style="color: ${char.color};">${char.name}</td>
      ${state.rooms.map(room => `
        <td>
          <input type="number" 
                 min="0" 
                 max="${state.timesteps}"
                 value="${state.visitCounts[char.name][room]}"
                 onchange="updateVisitCount('${char.name}', '${room}', this.value)"
                 placeholder="-">
        </td>
      `).join('')}
    </tr>
  `).join('');
}

// Update visit count
function updateVisitCount(charName, room, value) {
  state.visitCounts[charName][room] = value;
  saveState();
}

// State management (undo/redo)
function saveState() {
  const snapshot = JSON.stringify({
    placements: state.placements,
    visitCounts: state.visitCounts,
    notes: document.getElementById('notesEditor').innerHTML
  });
  
  // Remove future history if we're not at the end
  if (state.historyIndex < state.history.length - 1) {
    state.history = state.history.slice(0, state.historyIndex + 1);
  }
  
  state.history.push(snapshot);
  state.historyIndex++;
  
  // Limit history size
  if (state.history.length > 50) {
    state.history.shift();
    state.historyIndex--;
  }
  
  updateUndoRedoButtons();
  saveToLocalStorage();
}

function undo() {
  if (state.historyIndex > 0) {
    state.historyIndex--;
    restoreState(state.history[state.historyIndex]);
  }
}

function redo() {
  if (state.historyIndex < state.history.length - 1) {
    state.historyIndex++;
    restoreState(state.history[state.historyIndex]);
  }
}

function restoreState(snapshot) {
  const data = JSON.parse(snapshot);
  state.placements = data.placements;
  state.visitCounts = data.visitCounts;
  document.getElementById('notesEditor').innerHTML = data.notes;
  
  // Update all visuals
  for (let t = 1; t <= state.timesteps; t++) {
    updateNodeVisuals(t);
  }
  renderTrackingTable();
  updateUndoRedoButtons();
}

function updateUndoRedoButtons() {
  document.getElementById('undoBtn').disabled = state.historyIndex <= 0;
  document.getElementById('redoBtn').disabled = state.historyIndex >= state.history.length - 1;
}

// Keyboard shortcuts
document.addEventListener('keydown', (e) => {
  if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
    e.preventDefault();
    undo();
  } else if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {
    e.preventDefault();
    redo();
  }
});

// Button handlers
document.getElementById('undoBtn').addEventListener('click', undo);
document.getElementById('redoBtn').addEventListener('click', redo);

document.getElementById('clearBtn').addEventListener('click', () => {
  if (confirm('Clear all notes and placements?')) {
    // Reset placements
    for (let t = 1; t <= state.timesteps; t++) {
      state.rooms.forEach(room => {
        state.placements[t][room] = [];
      });
      updateNodeVisuals(t);
    }
    
    // Reset visit counts
    state.characters.forEach(char => {
      state.rooms.forEach(room => {
        state.visitCounts[char.name][room] = '';
      });
    });
    
    // Reset notes
    document.getElementById('notesEditor').innerHTML = '<p>Start taking notes here...</p>';
    
    renderTrackingTable();
    saveState();
  }
});

document.getElementById('exportBtn').addEventListener('click', () => {
  const data = {
    placements: state.placements,
    visitCounts: state.visitCounts,
    notes: document.getElementById('notesEditor').innerHTML,
    timestamp: new Date().toISOString()
  };
  
  const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = `kronologic-notes-${Date.now()}.json`;
  a.click();
  URL.revokeObjectURL(a.href);
});

// Auto-save notes
document.getElementById('notesEditor').addEventListener('input', () => {
  saveState();
});

// Local storage
function saveToLocalStorage() {
  try {
    localStorage.setItem('kronologic-notes', JSON.stringify({
      placements: state.placements,
      visitCounts: state.visitCounts,
      notes: document.getElementById('notesEditor').innerHTML
    }));
  } catch (e) {
    console.warn('Failed to save to localStorage:', e);
  }
}

function loadFromLocalStorage() {
  try {
    const saved = localStorage.getItem('kronologic-notes');
    if (saved) {
      const data = JSON.parse(saved);
      state.placements = data.placements || state.placements;
      state.visitCounts = data.visitCounts || state.visitCounts;
      if (data.notes) {
        document.getElementById('notesEditor').innerHTML = data.notes;
      }
    }
  } catch (e) {
    console.warn('Failed to load from localStorage:', e);
  }
}

// Initialize with example data
function initExample() {
  const exampleData = {
    rooms: ['Foyer', 'Stairs', 'Gallery', 'Masks', 'DanceRoom', 'MusicRoom'],
    characters: ['Manager', 'Mechanic', 'VIP', 'Detective', 'Servant', 'Journalist'],
    timesteps: 6,
    graphElements: [
      { data: { id: 'Foyer', name: 'Foyer' } },
      { data: { id: 'Stairs', name: 'Stairs' } },
      { data: { id: 'Gallery', name: 'Gallery' } },
      { data: { id: 'Masks', name: 'Masks' } },
      { data: { id: 'DanceRoom', name: 'DanceRoom' } },
      { data: { id: 'MusicRoom', name: 'MusicRoom' } },
      { data: { source: 'Foyer', target: 'Stairs' } },
      { data: { source: 'Foyer', target: 'Gallery' } },
      { data: { source: 'Gallery', target: 'Stairs' } },
      { data: { source: 'Gallery', target: 'Masks' } },
      { data: { source: 'Masks', target: 'DanceRoom' } },
      { data: { source: 'Masks', target: 'MusicRoom' } },
      { data: { source: 'MusicRoom', target: 'DanceRoom' } }
    ],
    graphLayout: {
      name: 'circle',
      fit: true,
      padding: 20
    }
  };
  
  initializeFromScenario(exampleData);
  loadFromLocalStorage();
}

// Start
initExample();
</script>

</body>
</html>
